<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Production Scheduler</title>
    <!-- Add Supabase Auth UI CSS -->
    <link rel="stylesheet" href="https://unpkg.com/@supabase/auth-ui-shared@0.0.11/dist/components.css" />
    <script src="https://unpkg.com/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f7fa;
            color: #333;
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .card {
            background: white;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border: 1px solid #e1e8ed;
        }

        .card h2 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 1.4em;
            font-weight: 600;
        }

        .form-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
        }

        /* Optional Overrides layout tuning */
        #optionalOverridesContent {
            grid-template-columns: repeat(3, minmax(280px, 1fr));
            column-gap: 24px;
            row-gap: 18px;
            align-items: start;
        }
        /* Make the two range groups span two columns so fields are wider */
        #orderBreakdownGroup { grid-column: 2 / span 2; }
        #orderHolidayGroup { grid-column: 2 / span 2; }
        .range-group {
            display: flex;
            align-items: center;
            gap: 12px;
            width: 100%;
        }
        .range-group input[type="datetime-local"] {
            flex: 1 1 0;
            min-width: 0; /* prevent overflow */
        }
        .range-group span {
            white-space: nowrap;
            color: #666;
        }

        label {
            font-weight: 500;
            margin-bottom: 5px;
            color: #555;
        }

        input, select, textarea {
            padding: 12px;
            border: 2px solid #e1e8ed;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }

        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .part-input-container {
            position: relative;
        }

        .part-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 2px solid #e1e8ed;
            border-top: none;
            border-radius: 0 0 8px 8px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }

        .suggestion-item {
            padding: 10px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
        }

        .suggestion-item:hover {
            background: #f8f9fa;
        }

        .chips-container {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .chip {
            background: #667eea;
            color: white;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .chip-remove {
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            font-size: 14px;
            padding: 0;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .chip-remove:hover {
            background: rgba(255,255,255,0.2);
        }

        .priority-group {
            display: flex;
            gap: 15px;
            margin-top: 5px;
        }

        .priority-option {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .priority-option input[type="radio"] {
            width: auto;
            margin: 0;
        }

        .tab-nav {
            display: flex;
            gap: 10px;
            margin-bottom: 0;
        }

        .tab-btn {
            padding: 12px 24px;
            border: none;
            background: #f8f9fa;
            color: #666;
            border-radius: 8px 8px 0 0;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .tab-btn.active {
            background: #667eea;
            color: white;
        }

        .tab-btn:hover:not(.active) {
            background: #e9ecef;
        }

        .tab-content {
            margin-top: -25px;
        }

        small {
            color: #888;
            font-size: 12px;
            margin-top: 2px;
            display: block;
        }

        .advanced-toggle {
            background: none;
            border: none;
            color: #667eea;
            cursor: pointer;
            font-size: 14px;
            text-decoration: underline;
            margin-bottom: 15px;
        }

        .advanced-options {
            display: none;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .advanced-options.show {
            display: grid;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            justify-content: center;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5a6fd8;
            transform: translateY(-1px);
        }

        .btn-success {
            background: #27ae60;
            color: white;
        }

        .btn-success:hover {
            background: #229954;
            transform: translateY(-1px);
        }

        .btn-danger {
            background: #e74c3c;
            color: white;
            padding: 6px 12px;
            font-size: 12px;
        }

        .btn-danger:hover {
            background: #c0392b;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #545b62;
        }

        .priority-low { background: #6c757d; }
        .priority-urgent { background: #dc3545; }
        .priority-high { background: #fd7e14; }
        .priority-normal { background: #28a745; }

        .collapsible-header {
            cursor: pointer;
            user-select: none;
            margin: 20px 0 10px 0;
            padding: 10px;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            transition: background-color 0.3s ease;
        }

        .collapsible-header:hover {
            background: #e9ecef;
        }

        .collapsible-header span {
            display: inline-block;
            transition: transform 0.3s ease;
            margin-right: 8px;
        }

        .optional-overrides-section {
            margin-top: 20px;
        }

        .operation-checkboxes {
            margin-top: 10px;
            padding: 10px;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            background: #f8f9fa;
        }

        .operation-checkbox-item {
            display: inline-block;
            margin: 5px 10px 5px 0;
        }

        .operation-checkbox-item input[type="checkbox"] {
            margin-right: 5px;
        }

        .operation-checkbox-item label {
            font-weight: normal;
            cursor: pointer;
        }

        .operation-dropdown-container {
            position: relative;
        }

        .operation-selector {
            display: flex;
            position: relative;
        }

        .operation-selector input {
            flex: 1;
            border-radius: 5px 0 0 5px;
            border-right: none;
        }

        .operation-btn {
            background: #007bff;
            color: white;
            border: 1px solid #007bff;
            border-radius: 0 5px 5px 0;
            padding: 8px 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .operation-btn:hover:not(:disabled) {
            background: #0056b3;
        }

        .operation-btn:disabled {
            background: #6c757d;
            border-color: #6c757d;
            cursor: not-allowed;
        }

        .operation-btn.open {
            transform: rotate(180deg);
        }

        .operation-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #dee2e6;
            border-top: none;
            border-radius: 0 0 5px 5px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            z-index: 1000;
            max-height: 250px;
            overflow-y: auto;
            animation: slideDown 0.2s ease-out;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .operation-dropdown-item {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            cursor: pointer;
            transition: background-color 0.2s ease;
            border-bottom: 1px solid #f1f3f4;
        }

        .operation-dropdown-item:last-child {
            border-bottom: none;
        }

        .operation-dropdown-item:hover {
            background-color: #f8f9fa;
        }

        .operation-dropdown-item input[type="checkbox"] {
            margin-right: 10px;
        }

        .operation-dropdown-item label {
            flex: 1;
            cursor: pointer;
            font-weight: normal;
        }

        .operation-dropdown-footer {
            padding: 10px 15px;
            border-top: 1px solid #dee2e6;
            background: #f8f9fa;
            display: flex;
            justify-content: space-between;
        }

        .operation-dropdown-footer button {
            padding: 5px 15px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }

        .btn-clear {
            background: #6c757d;
            color: white;
        }

        .btn-apply {
            background: #28a745;
            color: white;
        }

        .table-container {
            overflow-x: auto;
            margin-top: 20px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #e1e8ed;
        }

        /* Prevent wrapping in specific table cells (dates, times, timing text) */
        .nowrap {
            white-space: nowrap;
            word-break: keep-all;
        }

        th {
            background: #f8f9fa;
            font-weight: 600;
            color: #555;
        }

        tr:hover {
            background: #f8f9fa;
        }

        .action-bar {
            position: sticky;
            bottom: 0;
            background: white;
            padding: 20px;
            border-top: 2px solid #e1e8ed;
            display: flex;
            gap: 15px;
            justify-content: center;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
            margin: 20px -20px -20px -20px;
            border-radius: 0 0 12px 12px;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
            color: #667eea;
        }

        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .alert {
            padding: 12px 16px;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .alert-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .alert-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .form-grid {
                grid-template-columns: 1fr;
            }
            
            .action-bar {
                flex-direction: column;
            }
            
            .priority-group {
                flex-direction: column;
                gap: 10px;
            }
        }

        /* Sync Controls Styling */
        .sync-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-left: auto;
        }

        .btn-secondary {
            background: #6b7280;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.2s;
        }

        .btn-secondary:hover {
            background: #4b5563;
        }

        .btn-secondary:disabled {
            background: #9ca3af;
            cursor: not-allowed;
        }

        .sync-status {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            font-size: 12px;
        }

        .sync-status small {
            color: #6b7280;
            margin-top: 2px;
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .spinning {
            animation: spin 1s linear infinite;
        }

        /* Holiday Calendar Styles */
        .holiday-input-section {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            background-color: #f9f9f9;
        }
        
        .holiday-datetime-inputs {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .datetime-pair {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .datetime-pair label {
            font-weight: 600;
            color: #333;
            font-size: 14px;
        }
        
        .datetime-pair input {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .holiday-list-section {
            margin-top: 20px;
        }
        
        .holiday-list-container {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 6px;
            background-color: white;
        }
        
        .holiday-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }
        
        .holiday-table th,
        .holiday-table td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }
        
        .holiday-table th {
            background-color: #f5f5f5;
            font-weight: 600;
            position: sticky;
            top: 0;
        }
        
        .holiday-actions {
            display: flex;
            gap: 8px;
        }
        
        .btn-icon {
            padding: 4px 8px;
            font-size: 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .btn-edit {
            background-color: #007bff;
            color: white;
        }
        
        .btn-edit:hover {
            background-color: #0056b3;
        }
        
        .btn-delete {
            background-color: #dc3545;
            color: white;
        }
        
        .btn-delete:hover {
            background-color: #c82333;
        }
        
        .badge {
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
        }
        
        .badge-primary {
            background-color: #007bff;
            color: white;
        }
        
        .badge-secondary {
            background-color: #6c757d;
            color: white;
        }
        
        /* Machine Breakdown Styles */
        .breakdown-input-section {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            background-color: #f9f9f9;
        }
        
        .breakdown-machine-selection {
            margin-bottom: 15px;
        }
        
        .machine-checkbox-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 8px;
            padding: 10px;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            background-color: white;
        }
        
        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            cursor: pointer;
            padding: 5px;
            border-radius: 4px;
            transition: background-color 0.2s;
        }
        
        .checkbox-item:hover {
            background-color: #f0f8ff;
        }
        
        .checkbox-item input[type="checkbox"] {
            margin: 0;
            cursor: pointer;
        }
        
        .breakdown-datetime-inputs {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .breakdown-list-section {
            margin-top: 20px;
        }
        
        .breakdown-list-container {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 6px;
            background-color: white;
        }
        
        .breakdown-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }
        
        .breakdown-table th,
        .breakdown-table td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }
        
        .breakdown-table th {
            background-color: #f5f5f5;
            font-weight: 600;
            position: sticky;
            top: 0;
        }
        
        .machine-list {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }
        
        .machine-tag {
            background-color: #e3f2fd;
            color: #1976d2;
            padding: 2px 6px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 500;
        }
        
        /* Shifts Container Styling */
        .shifts-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 20px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background-color: #f8f9fa;
        }
        
        .shifts-container .form-group {
            margin-bottom: 0;
        }
        
        .shifts-container .form-group:last-child {
            margin-bottom: 0;
        }

        /* Advanced Settings layout grids */
        .advanced-grid-3 {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            align-items: start;
        }
        .advanced-grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-top: 20px;
            align-items: start;
        }
        @media (max-width: 1024px) {
            .advanced-grid-3, .advanced-grid-2 {
                grid-template-columns: 1fr;
            }
        }
        /* Compact form spacing */
        .form-group { margin-bottom: 10px; }
        .form-group label { display:block; margin-bottom: 6px; }
        .shifts-container { display: flex; flex-direction: column; gap: 8px; }
        .shifts-container .form-group { margin-bottom: 0; }
    </style>
</head>
<body>
    <!-- Loading overlay -->
    <div id="loadingOverlay" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); display: flex; justify-content: center; align-items: center; z-index: 1000; color: white; font-size: 1.5rem;">
        Loading...
    </div>

    <div class="container">
        <div class="card">
            <div class="card-header" style="display: flex; justify-content: space-between; align-items: center;">
                <h2>Production Schedule Generator</h2>
                <div style="display: flex; align-items: center; gap: 1rem;">
                    <span id="userInfo" style="font-size: 0.9rem; color: #666;"></span>
                    <button id="logoutBtn" class="btn btn-secondary" style="padding: 0.3rem 0.8rem; font-size: 0.9rem;">
                        Logout
                    </button>
                </div>
                <div class="sync-controls">
                    <button id="refreshDataBtn" class="btn btn-secondary" onclick="refreshRoutingData()">
                        <span id="refreshIcon">🔄</span> Refresh Data
                    </button>
                    <div class="sync-status">
                        <span id="syncStatus">📊 Local Data</span>
                        <small id="lastSync">Last sync: Never</small>
                    </div>
                </div>
            </div>
            <div class="header">
                <h1>🏭 Production Scheduler</h1>
                <p>Advanced Manufacturing Scheduling System</p>
            </div>

        <!-- Tab Navigation -->
        <div class="card">
            <div class="tab-nav">
                <button class="tab-btn active" onclick="switchTab('orders')">📋 Orders</button>
                <button class="tab-btn" onclick="switchTab('advanced')">⚙️ Advanced Settings</button>
            </div>
        </div>

        <!-- Orders Tab -->
        <div class="card tab-content" id="ordersTab">
            <h2>📝 Order Management</h2>
            <form id="orderForm">
                <h3>Mandatory Fields</h3>
                <div class="form-grid">
                    <div class="form-group">
                        <label for="partNumber">Part Number</label>
                        <div class="part-input-container">
                            <input type="text" id="partNumber" placeholder="Search part numbers..." required>
                            <div class="part-suggestions" id="partSuggestions"></div>
                        </div>
                    </div>

                    <div class="form-group">
                        <label for="operationSeq">Operation Sequence</label>
                        <div class="operation-dropdown-container">
                            <div class="operation-selector">
                                <input type="text" id="operationSeqDisplay" placeholder="Select a part number first" readonly disabled>
                                <button type="button" id="operationSeqBtn" class="operation-btn" onclick="toggleOperationDropdown()" disabled>
                                    <span>▼</span>
                                </button>
                            </div>
                            <div id="operationDropdown" class="operation-dropdown" style="display: none;">
                                <!-- Dynamic operation options will be populated here -->
                            </div>
                        </div>
                        <input type="hidden" id="operationSeq" value="">
                    </div>

                    <div class="form-group">
                        <label for="orderQuantity">Order Quantity</label>
                        <input type="number" id="orderQuantity" min="1" required>
                    </div>

                    <div class="form-group">
                        <label>Priority</label>
                        <div class="priority-group">
                            <div class="priority-option">
                                <input type="radio" id="priorityUrgent" name="priority" value="Urgent">
                                <label for="priorityUrgent">Urgent</label>
                            </div>
                            <div class="priority-option">
                                <input type="radio" id="priorityHigh" name="priority" value="High">
                                <label for="priorityHigh">High</label>
                            </div>
                            <div class="priority-option">
                                <input type="radio" id="priorityNormal" name="priority" value="Normal" checked>
                                <label for="priorityNormal">Normal</label>
                            </div>
                            <div class="priority-option">
                                <input type="radio" id="priorityLow" name="priority" value="Low">
                                <label for="priorityLow">Low</label>
                            </div>
                        </div>
                    </div>

                    <div class="form-group">
                        <label for="dueDate">Due Date</label>
                        <input type="date" id="dueDate" required>
                    </div>
                </div>

                <div class="optional-overrides-section">
                    <h3 class="collapsible-header" onclick="toggleOptionalOverrides()">
                        <span id="overrideToggleIcon">▶</span> Optional Overrides 
                        <small>(Click to expand advanced settings for this order)</small>
                    </h3>
                    <div class="form-grid" id="optionalOverridesContent" style="display: none;">
                        <div class="form-group">
                            <label for="orderBreakdownMachine">Breakdown Machine</label>
                            <select id="orderBreakdownMachine">
                                <option value="">Use Global Setting</option>
                                <option value="VMC 1">VMC 1</option>
                                <option value="VMC 2">VMC 2</option>
                                <option value="VMC 3">VMC 3</option>
                                <option value="VMC 4">VMC 4</option>
                                <option value="VMC 5">VMC 5</option>
                                <option value="VMC 6">VMC 6</option>
                                <option value="VMC 7">VMC 7</option>
                            </select>
                        </div>

                        <div class="form-group" id="orderBreakdownGroup">
                            <label for="orderBreakdownStart">Breakdown Date-Time Range</label>
                            <div class="range-group">
                                <input type="datetime-local" id="orderBreakdownStart">
                                <span>to</span>
                                <input type="datetime-local" id="orderBreakdownEnd">
                            </div>
                            <small>Choose a start and end. The machine will rest during this range.</small>
                        </div>

                        <div class="form-group">
                            <label for="orderStartDateTime">Order Start Date & Time (Per Order Rule)</label>
                            <input type="datetime-local" id="orderStartDateTime" placeholder="mm/dd/yyyy, --:-- --">
                            <small>📅 Please select the Start Date & Time for this order.<br>
                            ⚠️ This sets the earliest allowed start time for setup/processing of this order. The scheduler must not schedule this order before the chosen time — even if machines are free.<br>
                            <strong>Behavior rule:</strong> If Order Start Date-Time is defined → compare with Global Start Date-Time → actual order start = max(GlobalStart, OrderStart). If not defined → order is eligible immediately from Global Start Date-Time.<br>
                            <strong>Example:</strong> Global Start Date-Time = 2025-09-10 03:00, Order Start Date-Time = 2025-09-10 06:00 → This order must wait until 06:00 to begin setup, even though global clock starts at 03:00.</small>
                        </div>

                        <div class="form-group" id="orderHolidayGroup">
                            <label for="orderHolidayStart">Holiday</label>
                            <div class="range-group">
                                <input type="datetime-local" id="orderHolidayStart">
                                <span>to</span>
                                <input type="datetime-local" id="orderHolidayEnd">
                            </div>
                            <small>Choose a start and end. Time between will be treated as holiday for this order.</small>
                        </div>

                        <div class="form-group">
                            <label for="orderSetupWindow">Setup Availability Window</label>
                            <input type="text" id="orderSetupWindow" placeholder="08:00-18:00">
                            <small>Format: HH:MM-HH:MM</small>
                        </div>
                    </div>
                </div>

                <div style="display:flex; gap:10px; align-items:center; margin-top:10px;">
                    <button id="orderSubmitBtn" type="submit" class="btn btn-primary">➕ Add Order</button>
                    <button id="cancelEditBtn" type="button" class="btn btn-secondary" style="display:none;" onclick="cancelEdit()">✖️ Cancel</button>
                </div>
            </form>
        </div>

        <!-- Advanced Settings Tab -->
        <div class="card tab-content" id="advancedTab" style="display: none;">
            <h2>⚙️ Global Advanced Settings</h2>
            <div class="advanced-grid-3">
                <div class="form-group">
                    <label for="startDateTime">Global Start Date & Time (Master Clock)</label>
                    <input type="datetime-local" id="startDateTime" placeholder="mm/dd/yyyy, --:-- --">
                    
                </div>

                <!-- Global Setup Window (People-Dependent) -->
                <div class="form-group">
                    <label for="setupAvailabilityWindow">Global Setup Window (People-Dependent)</label>
                    <input type="text" id="setupAvailabilityWindow" value="06:00-22:00" placeholder="06:00-22:00">
                    <small>Format: HH:MM-HH:MM. Auto-filled from Shift 1 and Shift 2 below (earliest start to latest end). You can still override manually.</small>
                    <div class="shifts-container">
                        <div class="form-group">
                            <label for="shift1">Shift 1 (Controls Global Setup Window)</label>
                            <input type="text" id="shift1" value="06:00-14:00" placeholder="06:00-14:00">
                        </div>
                        <div class="form-group">
                            <label for="shift2">Shift 2 (Controls Global Setup Window)</label>
                            <input type="text" id="shift2" value="14:00-22:00" placeholder="14:00-22:00">
                        </div>
                    </div>
                </div>

                <div class="form-group">
                    <label>Production Window (Machine-Dependent)</label>
                    <div class="shifts-container">
                        <div class="form-group">
                            <label for="prodShift1">Shift 1 (Morning)</label>
                            <input type="text" id="prodShift1" value="06:00-14:00" placeholder="06:00-14:00">
                        </div>
                        <div class="form-group">
                            <label for="prodShift2">Shift 2 (Afternoon)</label>
                            <input type="text" id="prodShift2" value="14:00-22:00" placeholder="14:00-22:00">
                        </div>
                        <div class="form-group">
                            <label for="prodShift3">Shift 3 (Night)</label>
                            <input type="text" id="prodShift3" value="22:00-06:00" placeholder="22:00-06:00">
                        </div>
                    </div>
                    
                </div>

            </div><!-- /.advanced-grid-3 -->

            <div class="advanced-grid-2">
                <div class="form-group">
                    <label for="holidays">Holiday Calendar (Global Pauses)</label>
                    <div class="holiday-input-section">
                        <div class="holiday-datetime-inputs">
                            <div class="datetime-pair">
                                <label for="holidayStart">Start DateTime:</label>
                                <input type="datetime-local" id="holidayStart" placeholder="Start date and time">
                            </div>
                            <div class="datetime-pair">
                                <label for="holidayEnd">End DateTime:</label>
                                <input type="datetime-local" id="holidayEnd" placeholder="End date and time">
                            </div>
                            <div class="datetime-pair">
                                <label for="holidayReason">Reason (Optional):</label>
                                <input type="text" id="holidayReason" placeholder="e.g., National Holiday, Maintenance">
                            </div>
                        </div>
                        <button type="button" class="btn btn-primary" onclick="addHoliday()">➕ Add Holiday</button>
                    </div>
                    
                    <!-- Holiday List Display -->
                    <div class="holiday-list-section">
                        <h4>📅 Saved Holidays</h4>
                        <div class="holiday-list-container" id="holidayListContainer">
                            <table class="holiday-table" id="holidayTable">
                                <thead>
                                    <tr>
                                        <th>Start DateTime</th>
                                        <th>End DateTime</th>
                                        <th>Type</th>
                                        <th>Reason</th>
                                        <th>Actions</th>
                                    </tr>
                                </thead>
                                <tbody id="holidayTableBody">
                                    <tr>
                                        <td colspan="5" style="text-align: center; color: #888;">No holidays added yet</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>

                <div class="form-group">
                    <label for="breakdownMachines">Machine Breakdowns (Downtime Control)</label>
                    <div class="breakdown-input-section">
                        <div class="breakdown-machine-selection">
                            <label for="breakdownMachineSelect">Select Machines:</label>
                            <div class="machine-checkbox-group" id="machineCheckboxGroup">
                                <label class="checkbox-item"><input type="checkbox" value="VMC 1"> VMC 1</label>
                                <label class="checkbox-item"><input type="checkbox" value="VMC 2"> VMC 2</label>
                                <label class="checkbox-item"><input type="checkbox" value="VMC 3"> VMC 3</label>
                                <label class="checkbox-item"><input type="checkbox" value="VMC 4"> VMC 4</label>
                                <label class="checkbox-item"><input type="checkbox" value="VMC 5"> VMC 5</label>
                                <label class="checkbox-item"><input type="checkbox" value="VMC 6"> VMC 6</label>
                                <label class="checkbox-item"><input type="checkbox" value="VMC 7"> VMC 7</label>
                                <label class="checkbox-item"><input type="checkbox" value="VMC 8"> VMC 8</label>
                                <label class="checkbox-item"><input type="checkbox" value="VMC 9"> VMC 9</label>
                                <label class="checkbox-item"><input type="checkbox" value="VMC 10"> VMC 10</label>
                            </div>
                        </div>
                        
                        <div class="breakdown-datetime-inputs">
                            <div class="datetime-pair">
                                <label for="breakdownStart">Start DateTime:</label>
                                <input type="datetime-local" id="breakdownStart" placeholder="Start date and time" required>
                            </div>
                            <div class="datetime-pair">
                                <label for="breakdownEnd">End DateTime:</label>
                                <input type="datetime-local" id="breakdownEnd" placeholder="End date and time" required>
                            </div>
                            <div class="datetime-pair">
                                <label for="breakdownReason">Reason (Optional):</label>
                                <input type="text" id="breakdownReason" placeholder="e.g., Power Maintenance, Coolant Pump Failure">
                            </div>
                        </div>
                        <button type="button" class="btn btn-primary" onclick="addBreakdown()">🔧 Add Breakdown</button>
                    </div>
                    
                    <!-- Breakdown List Display -->
                    <div class="breakdown-list-section">
                        <h4>🔧 Saved Machine Breakdowns</h4>
                        <div class="breakdown-list-container">
                            <table class="breakdown-table" id="breakdownTable">
                                <thead>
                                    <tr>
                                        <th>Machines</th>
                                        <th>Start DateTime</th>
                                        <th>End DateTime</th>
                                        <th>Reason</th>
                                        <th>Actions</th>
                                    </tr>
                                </thead>
                                <tbody id="breakdownTableBody">
                                    <tr>
                                        <td colspan="5" style="text-align: center; color: #888;">No breakdowns added yet</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                    
                    
                </div>
            </div><!-- /.advanced-grid-2 -->
            </div>

            <button type="button" class="btn btn-secondary" onclick="saveAdvancedSettings()">💾 Save Settings</button>
        </div>

        <!-- Saved Orders Table -->
        <div class="card">
            <h2>📋 Saved Orders</h2>
            <div class="table-container">
                <table id="ordersTable">
                    <thead>
                        <tr>
                            <th>Part Number</th>
                            <th>Operation Seq</th>
                            <th>Order Quantity</th>
                            <th>Priority</th>
                            <th>Due Date</th>
                            <th>Breakdown Machine</th>
                            <th>Breakdown DateTime</th>
                            <th>Start DateTime</th>
                            <th>Holiday</th>
                            <th>Setup Window</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="ordersTableBody">
                        <tr>
                            <td colspan="11" style="text-align: center; color: #888;">No orders added yet</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Schedule Results -->
        <div class="card" id="resultsCard" style="display: none;">
            <h2>📊 Schedule Results</h2>
            <div id="scheduleAlerts"></div>
            <div class="table-container">
                <table id="resultsTable">
                    <thead>
                        <tr>
                            <th>Part Number</th>
                            <th>Order Qty</th>
                            <th>Priority</th>
                            <th>Batch ID</th>
                            <th>Batch Qty</th>
                            <th>Operation Seq</th>
                            <th>Operation Name</th>
                            <th>Machine</th>
                            <th>Person</th>
                            <th>Setup Start</th>
                            <th>Setup End</th>
                            <th>Run Start</th>
                            <th>Run End</th>
                            <th>Timing</th>
                            <th>Due Date</th>
                        </tr>
                    </thead>
                    <tbody id="resultsTableBody"></tbody>
                </table>
            </div>
        </div>

        <!-- Loading Indicator -->
        <div class="loading" id="loadingIndicator">
            <div class="spinner"></div>
            <p>Processing schedule...</p>
        </div>

        <!-- Action Bar -->
        <div class="action-bar">
            <button class="btn btn-success" onclick="runSchedule()">
                ▶️ Run Schedule
            </button>
            <button class="btn btn-secondary" onclick="exportToExcel()" id="exportBtn" disabled>
                ⬇️ Export Excel
            </button>
        </div>
    </div>


    <!-- Add Supabase client -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <!-- Initialize Supabase first -->
    <script>
        // Create a global Supabase client initialization function
        function initSupabase() {
            const SUPABASE_URL = 'https://sxnaopzgaddvziplrlbe.supabase.co';
            const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InN4bmFvcHpnYWRkdnppcGxybGJlIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY2MjUyODQsImV4cCI6MjA3MjIwMTI4NH0.o3UAaJtrNpVh_AsljSC1oZNkJPvQomedvtJlXTE3L6w';
            
            // Initialize and return the Supabase client
            return supabase.createClient(SUPABASE_URL, SUPABASE_KEY, {
                auth: {
                    autoRefreshToken: true,
                    persistSession: true,
                    detectSessionInUrl: false, // Disable URL session detection to prevent redirect loops
                    storage: window.localStorage
                }
            });
        }
        
        // Initialize Supabase immediately
        try {
            const supabase = initSupabase();
            window.supabase = supabase; // Make available globally
            console.log('Supabase initialized successfully');
            
            // Check for session in URL hash and clear it to prevent redirect loops
            if (window.location.hash) {
                const hash = window.location.hash;
                if (hash.includes('access_token') || hash.includes('error=')) {
                    // Clear the hash without refreshing
                    history.replaceState(null, null, ' ');
                }
            }
        } catch (error) {
            console.error('Failed to initialize Supabase:', error);
            // Show error to user
            const errorElement = document.createElement('div');
            errorElement.style.color = 'red';
            errorElement.style.padding = '20px';
            errorElement.style.textAlign = 'center';
            errorElement.textContent = 'Failed to initialize the application. Please refresh the page or contact support.';
            document.body.prepend(errorElement);
        }
    </script>
    
    <!-- Load other scripts -->
    <script src="app.js"></script>
    <script src="data.js"></script>
    <script src="x10.js"></script>
    <script src="x10-browser.js?v=4"></script>
    
    <script>
        // Initialize the app after checking authentication
        async function initializeApp() {
            try {
                // Wait for Supabase to be fully initialized
                if (!window.supabase) {
                    console.error('Supabase client not initialized');
                    throw new Error('Authentication service not available');
                }
                
                // Check authentication
                const { data: { session }, error } = await window.supabase.auth.getSession();
                
                if (error) {
                    console.error('Error getting session:', error);
                    window.location.replace('auth.html');
                    return;
                }
                
                if (!session) {
                    console.log('No active session, redirecting to login');
                    // Clear any existing session data
                    await window.supabase.auth.signOut();
                    window.location.replace('auth.html');
                    return;
                }
                
                console.log('User authenticated, proceeding to app');

                // Hide loading overlay when app is initialized
                const loadingOverlay = document.getElementById('loadingOverlay');
                if (loadingOverlay) {
                    loadingOverlay.style.display = 'none';
                }
                
                // Initialize your existing app
                loadPersistedRoutingData();
                loadPersistedLastSync();
                
                // Check if we have persisted data
                if (window.OP_MASTER && window.OP_MASTER.length > 0) {
                    // Update UI with existing data
                    updateOrdersTable();
                    initializeAutoSync();
                } else {
                    // Try to load data if none exists
                    refreshRoutingData();
                }
                
                // Set default due date
                setDefaultDueDate();
            } catch (error) {
                console.error('Initialization error:', error);
                window.location.replace('auth.html');
            }
        }

        // Start the app initialization
        document.addEventListener('DOMContentLoaded', async function() {
            await initializeApp();
            // Initialize other components after auth check passes
            setupPartNumberSearch();
            
            // Initialize breakdown table on page load
            updateBreakdownTable();
            setupFormSubmission();
            setDefaultDueDate();
            loadPersistedRoutingData();
            loadPersistedLastSync();
            initializeAutoSync();
            initializeSyncStatus();
            
            // Wire shift inputs to control Global Setup Window
            const s1 = document.getElementById('shift1');
            const s2 = document.getElementById('shift2');
            if (s1) s1.addEventListener('input', syncSetupWindowFromShifts);
            if (s2) s2.addEventListener('input', syncSetupWindowFromShifts);
            // Initial sync to populate the window from current shift values
            syncSetupWindowFromShifts();
            
            // Add logout button handler
            const logoutBtn = document.getElementById('logoutBtn');
            if (logoutBtn) {
                logoutBtn.addEventListener('click', async function() {
                    try {
                        console.log('Logging out user...');
                        
                        // Sign out from Supabase
                        const { error } = await window.supabase.auth.signOut();
                        if (error) throw error;
                        
                        // Clear all session-related data from localStorage
                        const keys = Object.keys(localStorage);
                        keys.forEach(key => {
                            if (key.includes('supabase') || key.includes('sb-')) {
                                localStorage.removeItem(key);
                            }
                        });
                        
                        console.log('Logout successful, redirecting to login page');
                        
                        // Use replace to prevent back button issues
                        window.location.replace('auth.html?logged_out=true');
                    } catch (error) {
                        console.error('Logout error:', error);
                        alert('Failed to log out. Please try again.');
                    }
                });
            }
        });
    </script>

    <script>
        // Global variables
        let savedOrders = [];
        let scheduleResults = [];
        let savedHolidays = []; // Holiday storage
        let editingHolidayId = null; // Track which holiday is being edited
        let savedBreakdowns = []; // Machine breakdown storage
        let editingBreakdownId = null; // Track which breakdown is being edited
        let selectedPartNumber = '';
        let editingOrderId = null; // when not null, form is in edit mode
        let advancedSettings = {
            startDateTime: null,
            setupAvailabilityWindow: '06:00-22:00',
            breakdownMachines: [],
            breakdownDateTime: '',
            holidays: '',
            shift1: '06:00-14:00',
            shift2: '14:00-22:00',
            shift3: '22:00-06:00'
        };

        // Helper: get unique part numbers from the current operations master data
        function getAvailablePartNumbers() {
            try {
                return [...new Set((window.OP_MASTER || []).map(op => String(op.PartNumber).trim()))].sort();
            } catch (e) {
                console.warn('Failed to compute available part numbers:', e);
                return [];
            }
        }

        // Removed duplicate DOMContentLoaded listener - consolidated above

        function setDefaultDueDate() {
            const tomorrow = new Date();
            tomorrow.setDate(tomorrow.getDate() + 1);
            document.getElementById('dueDate').value = tomorrow.toISOString().split('T')[0];
        }

        function setupPartNumberSearch() {
            const partInput = document.getElementById('partNumber');
            const suggestions = document.getElementById('partSuggestions');

            partInput.addEventListener('input', function() {
                const query = this.value.toLowerCase();
                const parts = getAvailablePartNumbers();
                let matches = [];
                if (query.length === 0) {
                    matches = parts.slice(0, 20);
                } else {
                    matches = parts.filter(part => part.toLowerCase().includes(query));
                }

                if (matches.length > 0) {
                    suggestions.innerHTML = matches.map(part => 
                        `<div class="suggestion-item" onclick="selectPartNumber('${part}')">${part}</div>`
                    ).join('');
                    suggestions.style.display = 'block';
                } else {
                    suggestions.style.display = 'none';
                }
            });

            // Show initial list on focus
            partInput.addEventListener('focus', function() {
                const parts = getAvailablePartNumbers();
                const matches = parts.slice(0, 20);
                if (matches.length > 0) {
                    suggestions.innerHTML = matches.map(part => 
                        `<div class="suggestion-item" onclick="selectPartNumber('${part}')">${part}</div>`
                    ).join('');
                    suggestions.style.display = 'block';
                }
            });

            // Hide suggestions when clicking outside
            document.addEventListener('click', function(e) {
                if (!e.target.closest('.part-input-container')) {
                    suggestions.style.display = 'none';
                }
            });
        }

        function selectPartNumber(partNumber) {
            selectedPartNumber = partNumber;
            document.getElementById('partNumber').value = partNumber;
            document.getElementById('partSuggestions').style.display = 'none';
            
            // Populate operation sequences for selected part
            populateOperationSequences(partNumber);
        }

        let availableOperations = [];

        function populateOperationSequences(partNumber) {
            const operationSeqDisplay = document.getElementById('operationSeqDisplay');
            const operationSeqBtn = document.getElementById('operationSeqBtn');
            
            // Get all operations for this part number
            availableOperations = window.OP_MASTER.filter(op => op.PartNumber === partNumber);
            
            if (availableOperations.length === 0) {
                operationSeqDisplay.placeholder = 'No operations found';
                operationSeqBtn.disabled = true;
                return;
            }
            
            // Sort operations by sequence
            availableOperations.sort((a, b) => a.OperationSeq - b.OperationSeq);
            
            // Enable the button and update placeholder
            operationSeqDisplay.placeholder = 'Click to select operations';
            operationSeqDisplay.value = 'All operations';
            operationSeqBtn.disabled = false;
            
            // Set default value
            document.getElementById('operationSeq').value = '';
        }

        function toggleOperationDropdown() {
            if (availableOperations.length === 0) return;
            
            const dropdown = document.getElementById('operationDropdown');
            const btn = document.getElementById('operationSeqBtn');
            
            if (dropdown.style.display === 'none') {
                populateDropdownContent();
                dropdown.style.display = 'block';
                btn.classList.add('open');
            } else {
                dropdown.style.display = 'none';
                btn.classList.remove('open');
            }
        }

        function populateDropdownContent() {
            const dropdown = document.getElementById('operationDropdown');
            
            // Create dropdown content
            let dropdownHTML = `
                <div class="operation-dropdown-item" onclick="toggleDropdownItem(this, '')">
                    <input type="checkbox" id="dropdown_all" value="" ${document.getElementById('operationSeq').value === '' ? 'checked' : ''}>
                    <label><strong>All Operations</strong></label>
                </div>
            `;
            
            availableOperations.forEach(op => {
                const currentValue = document.getElementById('operationSeq').value;
                const isChecked = currentValue.includes(op.OperationSeq.toString());
                
                dropdownHTML += `
                    <div class="operation-dropdown-item" onclick="toggleDropdownItem(this, '${op.OperationSeq}')">
                        <input type="checkbox" id="dropdown_op_${op.OperationSeq}" value="${op.OperationSeq}" ${isChecked ? 'checked' : ''}>
                        <label>Op ${op.OperationSeq}: ${op.OperationName}</label>
                    </div>
                `;
            });
            
            dropdownHTML += `
                <div class="operation-dropdown-footer">
                    <button type="button" class="btn-clear" onclick="clearAllOperations()">Clear All</button>
                    <button type="button" class="btn-apply" onclick="applyOperationSelection()">OK</button>
                </div>
            `;
            
            dropdown.innerHTML = dropdownHTML;
        }

        function toggleDropdownItem(item, value) {
            const checkbox = item.querySelector('input[type="checkbox"]');
            checkbox.checked = !checkbox.checked;
            
            if (value === '') {
                // All operations selected
                if (checkbox.checked) {
                    // Uncheck all individual operations
                    document.querySelectorAll('#operationDropdown input[type="checkbox"]:not(#dropdown_all)').forEach(cb => {
                        cb.checked = false;
                    });
                }
            } else {
                // Individual operation selected
                if (checkbox.checked) {
                    // Uncheck "All operations"
                    document.getElementById('dropdown_all').checked = false;
                }
            }
        }

        function clearAllOperations() {
            document.querySelectorAll('#operationDropdown input[type="checkbox"]').forEach(cb => {
                cb.checked = false;
            });
            document.getElementById('dropdown_all').checked = true;
        }

        function applyOperationSelection() {
            const allCheckbox = document.getElementById('dropdown_all');
            const operationCheckboxes = document.querySelectorAll('#operationDropdown input[type="checkbox"]:not(#dropdown_all):checked');
            
            const operationSeqDisplay = document.getElementById('operationSeqDisplay');
            const operationSeqHidden = document.getElementById('operationSeq');
            
            console.log('Applying operation selection...');
            console.log('All checkbox checked:', allCheckbox?.checked);
            console.log('Selected operation checkboxes:', operationCheckboxes.length);
            
            if (allCheckbox?.checked || operationCheckboxes.length === 0) {
                operationSeqDisplay.value = 'All operations';
                operationSeqHidden.value = '';
                console.log('Set to: All operations');
            } else {
                const selectedOps = Array.from(operationCheckboxes).map(cb => cb.value);
                const selectedNames = selectedOps.map(opSeq => {
                    const op = availableOperations.find(o => o.OperationSeq.toString() === opSeq);
                    return `Op ${opSeq}`;
                });
                
                operationSeqDisplay.value = selectedNames.join(', ');
                operationSeqHidden.value = selectedOps.join(',');
                console.log('Set to specific operations:', selectedOps.join(','));
                console.log('Display value:', selectedNames.join(', '));
            }
            
            // Close dropdown
            document.getElementById('operationDropdown').style.display = 'none';
            document.getElementById('operationSeqBtn').classList.remove('open');
        }

        // Helper: derive operation sequence from current checkbox state
        function deriveOperationSeqFromCheckboxes() {
            const allCheckbox = document.getElementById('dropdown_all');
            const operationCheckboxes = document.querySelectorAll('#operationDropdown input[type="checkbox"]:not(#dropdown_all):checked');
            const operationSeqDisplay = document.getElementById('operationSeqDisplay');
            const operationSeqHidden = document.getElementById('operationSeq');
            if (allCheckbox && allCheckbox.checked) {
                operationSeqDisplay.value = 'All operations';
                operationSeqHidden.value = '';
                return '';
            }
            if (operationCheckboxes && operationCheckboxes.length > 0) {
                const selectedOps = Array.from(operationCheckboxes).map(cb => cb.value);
                operationSeqDisplay.value = selectedOps.map(s => `Op ${s}`).join(', ');
                operationSeqHidden.value = selectedOps.join(',');
                return operationSeqHidden.value;
            }
            // Default to All if nothing selected
            operationSeqDisplay.value = 'All operations';
            operationSeqHidden.value = '';
            return '';
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', function(event) {
            const container = document.querySelector('.operation-dropdown-container');
            if (container && !container.contains(event.target)) {
                const dropdown = document.getElementById('operationDropdown');
                const btn = document.getElementById('operationSeqBtn');
                dropdown.style.display = 'none';
                btn.classList.remove('open');
            }
        });

        function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');

            // Show/hide tab content
            document.getElementById('ordersTab').style.display = tabName === 'orders' ? 'block' : 'none';
            document.getElementById('advancedTab').style.display = tabName === 'advanced' ? 'block' : 'none';
        }

        function saveAdvancedSettings() {
            advancedSettings = {
                startDateTime: document.getElementById('startDateTime').value,
                setupAvailabilityWindow: document.getElementById('setupAvailabilityWindow').value,
                breakdownMachines: Array.from(document.getElementById('breakdownMachines').selectedOptions).map(opt => opt.value),
                breakdownDateTime: document.getElementById('breakdownDateTime').value,
                holidays: document.getElementById('holidays').value,
                shift1: document.getElementById('shift1').value,
                shift2: document.getElementById('shift2').value,
                shift3: document.getElementById('shift3').value
            };
            showAlert('Advanced settings saved successfully!', 'success');
        }

        function toggleAdvanced() {
            const options = document.getElementById('advancedOptions');
            options.classList.toggle('show');
        }

        function setupFormSubmission() {
            document.getElementById('orderForm').addEventListener('submit', function(e) {
                e.preventDefault();
                addOrder();
            });
            // Keep breakdown range always enabled; clear values if no machine selected
            const brMachineSel = document.getElementById('orderBreakdownMachine');
            const brStart = document.getElementById('orderBreakdownStart');
            const brEnd = document.getElementById('orderBreakdownEnd');
            if (brMachineSel) {
                brMachineSel.addEventListener('change', () => {
                    if (!brMachineSel.value) { brStart.value = ''; brEnd.value = ''; }
                });
            }
        }

        // Build breakdown range string like: "YYYY-MM-DD HH:MM → YYYY-MM-DD HH:MM"
        function buildBreakdownRangeString() {
            const machine = document.getElementById('orderBreakdownMachine').value;
            const s = document.getElementById('orderBreakdownStart').value;
            const e = document.getElementById('orderBreakdownEnd').value;
            if (!machine) return null; // machine not specified => treat as Global
            if (!s || !e) return null; // incomplete
            const start = new Date(s);
            const end = new Date(e);
            if (!(start instanceof Date) || isNaN(start) || !(end instanceof Date) || isNaN(end) || start >= end) return null;
            const startStr = s.replace('T', ' ');
            const endStr = e.replace('T', ' ');
            return `${startStr} → ${endStr}`;
        }

        // Parse stored range back into datetime-local inputs
        function parseBreakdownRangeToInputs(rangeStr) {
            if (!rangeStr || typeof rangeStr !== 'string') return { startVal: '', endVal: '' };
            const s = rangeStr.trim();
            let sep = '';
            if (s.includes('→')) sep = '→';
            else if (s.includes(' - ')) sep = ' - ';
            else if (s.toLowerCase().includes(' to ')) sep = ' to ';
            if (!sep) return { startVal: '', endVal: '' };
            const parts = s.split(sep);
            if (parts.length !== 2) return { startVal: '', endVal: '' };
            return { startVal: toLocalInput(parts[0].trim()), endVal: toLocalInput(parts[1].trim()) };
        }

        function toLocalInput(str) {
            if (!str) return '';
            // If already like YYYY-MM-DDTHH:MM
            if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/.test(str)) return str;
            // If like YYYY-MM-DD HH:MM
            if (/^\d{4}-\d{2}-\d{2} \d{2}:\d{2}$/.test(str)) return str.replace(' ', 'T');
            // If like DD/MM/YYYY HH:MM
            const m = str.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4}) (\d{1,2}):(\d{2})$/);
            if (m) {
                const dd = m[1].padStart(2, '0');
                const mm = m[2].padStart(2, '0');
                const yyyy = m[3];
                const HH = m[4].padStart(2, '0');
                const MM = m[5];
                return `${yyyy}-${mm}-${dd}T${HH}:${MM}`;
            }
            // Fallback: try Date
            const d = new Date(str);
            if (isNaN(d)) return '';
            const yyyy = d.getFullYear();
            const mm = String(d.getMonth() + 1).padStart(2, '0');
            const dd = String(d.getDate()).padStart(2, '0');
            const HH = String(d.getHours()).padStart(2, '0');
            const MM = String(d.getMinutes()).padStart(2, '0');
            return `${yyyy}-${mm}-${dd}T${HH}:${MM}`;
        }

        // Build holiday range string like breakdown, but no enabling condition
        function buildHolidayRangeString() {
            const s = document.getElementById('orderHolidayStart').value;
            const e = document.getElementById('orderHolidayEnd').value;
            if (!s || !e) return null;
            const start = new Date(s);
            const end = new Date(e);
            if (!(start instanceof Date) || isNaN(start) || !(end instanceof Date) || isNaN(end) || start >= end) return null;
            return `${s.replace('T',' ')} → ${e.replace('T',' ')}`;
        }

        function parseHolidayRangeToInputs(rangeStr) {
            if (!rangeStr || typeof rangeStr !== 'string') return { startVal: '', endVal: '' };
            const s = rangeStr.trim();
            let sep = '';
            if (s.includes('→')) sep = '→';
            else if (s.includes(' - ')) sep = ' - ';
            else if (s.toLowerCase().includes(' to ')) sep = ' to ';
            if (!sep) return { startVal: '', endVal: '' };
            const parts = s.split(sep);
            if (parts.length !== 2) return { startVal: '', endVal: '' };
            return { startVal: toLocalInput(parts[0].trim()), endVal: toLocalInput(parts[1].trim()) };
        }

        function addOrder() {
            // Validate mandatory fields
            if (!selectedPartNumber) {
                alert('Please select a part number');
                return;
            }

            const quantity = parseInt(document.getElementById('orderQuantity').value);
            if (!quantity || quantity <= 0) {
                alert('Please enter a valid order quantity');
                return;
            }

            const priorityElement = document.querySelector('input[name="priority"]:checked');
            if (!priorityElement) {
                alert('Please select a priority');
                return;
            }

            const dueDate = document.getElementById('dueDate').value;
            if (!dueDate) {
                alert('Please select a due date');
                return;
            }

            // Ensure latest checkbox selections are captured even if OK wasn't clicked
            let operationSeq = document.getElementById('operationSeq').value;
            try {
                // If the dropdown exists, derive from its current checkbox state
                if (document.getElementById('operationDropdown')) {
                    operationSeq = deriveOperationSeqFromCheckboxes();
                }
            } catch (e) {
                console.warn('Failed deriving operation sequence from checkboxes, using hidden value:', e);
            }
            
            // Debug: Check what operation sequence value we're getting
            console.log('Order submission - operationSeq value:', operationSeq);
            console.log('Order submission - operationSeqDisplay value:', document.getElementById('operationSeqDisplay').value);
            
            // Filter operations based on selection
            const filteredOperations = getFilteredOperations(selectedPartNumber, operationSeq);
            if (filteredOperations.length === 0) {
                alert('No operations found for the selected criteria. Please check your operation selection.');
                return;
            }
            
            console.log('Order submission - Final filtered operations:', filteredOperations.map(op => `Op ${op.OperationSeq}: ${op.OperationName}`));

            // Capture optional overrides
            const order = {
                id: editingOrderId !== null ? editingOrderId : Date.now(),
                partNumber: selectedPartNumber,
                operationSeq: operationSeq || null,
                filteredOperations: filteredOperations, // Store filtered operations
                quantity: quantity,
                priority: priorityElement.value,
                dueDate: dueDate,
                // Optional overrides (null if blank, will use global settings)
                breakdownMachine: document.getElementById('orderBreakdownMachine').value || null,
                breakdownDateTime: buildBreakdownRangeString(),
                startDateTime: document.getElementById('orderStartDateTime').value || null,
                holidayRange: buildHolidayRangeString(),
                setupWindow: document.getElementById('orderSetupWindow').value || null
            };

            if (editingOrderId !== null) {
                // Update existing order
                const idx = savedOrders.findIndex(o => o.id === editingOrderId);
                if (idx !== -1) savedOrders[idx] = order; else savedOrders.push(order);
                updateOrdersTable();
                exitEditMode();
                showAlert('Order updated successfully! Click "Run Schedule" to generate results.', 'success');
            } else {
                // Create new order
                savedOrders.push(order);
                updateOrdersTable();
                resetForm();
                showAlert('Order added successfully!', 'success');
            }
        }

        function getFilteredOperations(partNumber, operationSeq) {
            // Get all operations for this part number from master routing
            const allOperations = window.OP_MASTER.filter(op => op.PartNumber === partNumber);
            
            console.log(`Found ${allOperations.length} total operations for ${partNumber}:`, 
                allOperations.map(op => `Op ${op.OperationSeq}: ${op.OperationName}`));
            
            if (!operationSeq || operationSeq === '') {
                // "All operations" selected - include everything
                console.log('Selected: ALL operations');
                return allOperations.sort((a, b) => a.OperationSeq - b.OperationSeq);
            } else {
                // Specific operations selected (e.g., "1,2" or "3,4")
                const selectedSeqs = operationSeq.split(',').map(seq => parseInt(seq.trim()));
                console.log('Selected operation sequences:', selectedSeqs);
                
                const filteredOps = allOperations.filter(op => selectedSeqs.includes(op.OperationSeq));
                console.log(`Filtered to ${filteredOps.length} operations:`, 
                    filteredOps.map(op => `Op ${op.OperationSeq}: ${op.OperationName}`));
                
                // CRITICAL: Only return operations that match the selected sequences
                // This prevents any excluded operations from appearing in results
                return filteredOps.sort((a, b) => a.OperationSeq - b.OperationSeq);
            }
        }

        function toggleOptionalOverrides() {
            const content = document.getElementById('optionalOverridesContent');
            const icon = document.getElementById('overrideToggleIcon');
            
            if (content.style.display === 'none') {
                content.style.display = 'grid';
                icon.textContent = '▼';
                icon.style.transform = 'rotate(90deg)';
            } else {
                content.style.display = 'none';
                icon.textContent = '▶';
                icon.style.transform = 'rotate(0deg)';
            }
        }

        function resetForm() {
            document.getElementById('orderForm').reset();
            selectedPartNumber = '';
            setDefaultDueDate();
            // Clear holiday range explicitly (since reset may not affect datetime-local consistently across browsers)
            const holStart = document.getElementById('orderHolidayStart');
            const holEnd = document.getElementById('orderHolidayEnd');
            if (holStart) holStart.value = '';
            if (holEnd) holEnd.value = '';
            document.querySelector('input[name="priority"][value="Normal"]').checked = true;
            
            // Reset optional overrides section to collapsed state
            document.getElementById('optionalOverridesContent').style.display = 'none';
            document.getElementById('overrideToggleIcon').textContent = '▶';
            document.getElementById('overrideToggleIcon').style.transform = 'rotate(0deg)';
        }

        function updateOrdersTable() {
            const tbody = document.getElementById('ordersTableBody');
            
            if (savedOrders.length === 0) {
                tbody.innerHTML = '<tr><td colspan="11" style="text-align: center; color: #888;">No orders added yet</td></tr>';
                return;
            }

            tbody.innerHTML = savedOrders.map(order => {
                // Display operation sequences more clearly
                let operationDisplay = 'All';
                if (order.filteredOperations && order.filteredOperations.length > 0) {
                    // Prefer the actual filtered ops list for accuracy
                    operationDisplay = order.filteredOperations.map(op => `Op ${op.OperationSeq}`).join(', ');
                } else if (order.operationSeq) {
                    operationDisplay = order.operationSeq;
                }
                
                return `
                <tr>
                    <td>${order.partNumber}</td>
                    <td>${operationDisplay}</td>
                    <td>${order.quantity}</td>
                    <td><span class="priority-${order.priority.toLowerCase()}">${order.priority}</span></td>
                    <td>${new Date(order.dueDate).toLocaleDateString()}</td>
                    <td>${order.breakdownMachine || '<em>Global</em>'}</td>
                    <td>${order.breakdownDateTime || '<em>Global</em>'}</td>
                    <td>${order.startDateTime ? new Date(order.startDateTime).toLocaleString() : '<em>Global</em>'}</td>
                    <td>${order.holidayRange || '<em>Global</em>'}</td>
                    <td>${order.setupWindow || '<em>Global</em>'}</td>
                    <td>
                        <button class="btn btn-secondary" style="margin-right:6px;" onclick="editOrder(${order.id})">Edit</button>
                        <button class="btn btn-danger" onclick="deleteOrder(${order.id})">Delete</button>
                    </td>
                </tr>
                `;
            }).join('');
        }

        function deleteOrder(orderId) {
            if (confirm('Are you sure you want to delete this order?')) {
                savedOrders = savedOrders.filter(order => order.id !== orderId);
                updateOrdersTable();
                showAlert('Order deleted successfully!', 'success');
            }
        }

        // Enter edit mode with an existing order
        function editOrder(orderId) {
            const order = savedOrders.find(o => o.id === orderId);
            if (!order) return;
            editingOrderId = order.id;

            // Show Orders tab
            document.getElementById('ordersTab').style.display = 'block';
            document.getElementById('advancedTab').style.display = 'none';

            // Prefill fields
            selectedPartNumber = order.partNumber;
            const partInput = document.getElementById('partNumber');
            partInput.value = order.partNumber;
            partInput.disabled = true; // lock part number during edit

            // Populate operations for part and set selection
            populateOperationSequences(order.partNumber);
            const opDisplay = document.getElementById('operationSeqDisplay');
            const opHidden = document.getElementById('operationSeq');
            opHidden.value = order.operationSeq || '';
            if (!order.operationSeq || order.operationSeq === '') {
                opDisplay.value = 'All operations';
            } else {
                const seqs = order.operationSeq.split(',').map(s => s.trim()).filter(Boolean);
                opDisplay.value = seqs.map(s => `Op ${s}`).join(', ');
            }

            document.getElementById('orderQuantity').value = order.quantity;
            const priorityValue = order.priority || 'Normal';
            const prRadio = document.querySelector(`input[name="priority"][value="${priorityValue}"]`);
            if (prRadio) prRadio.checked = true;
            document.getElementById('dueDate').value = order.dueDate;

            document.getElementById('orderBreakdownMachine').value = order.breakdownMachine || '';
            // Prefill breakdown range fields
            const { startVal, endVal } = parseBreakdownRangeToInputs(order.breakdownDateTime || '');
            const brStart = document.getElementById('orderBreakdownStart');
            const brEnd = document.getElementById('orderBreakdownEnd');
            brStart.value = startVal;
            brEnd.value = endVal;
            const brMachineSel = document.getElementById('orderBreakdownMachine');
            document.getElementById('orderStartDateTime').value = order.startDateTime || '';
            // Prefill holiday range
            const { startVal: holS, endVal: holE } = parseHolidayRangeToInputs(order.holidayRange || '');
            const holStart = document.getElementById('orderHolidayStart');
            const holEnd = document.getElementById('orderHolidayEnd');
            holStart.value = holS;
            holEnd.value = holE;
            document.getElementById('orderSetupWindow').value = order.setupWindow || '';

            // Update buttons
            document.getElementById('orderSubmitBtn').textContent = '✔️ Update Order';
            document.getElementById('cancelEditBtn').style.display = 'inline-flex';
        }

        function cancelEdit() { exitEditMode(); }

        function exitEditMode() {
            editingOrderId = null;
            // unlock part input
            const partInput = document.getElementById('partNumber');
            partInput.disabled = false;
            resetForm();
            document.getElementById('orderSubmitBtn').textContent = '➕ Add Order';
            document.getElementById('cancelEditBtn').style.display = 'none';
        }

        // Schedule only a single order
        function runScheduleForSingleOrder(order) {
            document.getElementById('loadingIndicator').style.display = 'block';
            document.getElementById('resultsCard').style.display = 'none';

            setTimeout(() => {
                try {
                    const single = processOrderSingle(order);
                    scheduleResults = single; // show only this order
                    displayResults();
                    document.getElementById('exportBtn').disabled = false;
                } catch (error) {
                    console.error('Scheduling error (single):', error);
                    showAlert('Error generating schedule for updated order: ' + error.message, 'error');
                } finally {
                    document.getElementById('loadingIndicator').style.display = 'none';
                }
            }, 300);
        }

        // Process a single order using the same pipeline rules
        function processOrderSingle(order) {
            const results = [];
            const alerts = [];
            const machineSchedule = {}; // Track when each machine is available
            const operatorSchedule = {}; // Track operator availability per shift
            const allMachines = ["VMC 1", "VMC 2", "VMC 3", "VMC 4", "VMC 5", "VMC 6", "VMC 7"];
            allMachines.forEach(m => machineSchedule[m] = getNextShiftStart());
            ;["A","B","C","D"].forEach(p => operatorSchedule[p] = getNextShiftStart());

            let operations = Array.isArray(order.filteredOperations) ? order.filteredOperations.slice() : [];
            if (operations.length === 0) {
                alerts.push(`No filtered operations present for ${order.partNumber}.`);
                return { rows: results, alerts };
            }
            if (order.operationSeq && order.operationSeq !== '') {
                const selectedSeqs = order.operationSeq.split(',').map(s => parseInt(s.trim()));
                operations = operations.filter(op => selectedSeqs.includes(op.OperationSeq));
            }

            const engineResult = runSchedulingInBrowser([order], operations);
            if (engineResult.success) {
                engineResult.outputData.mainOutput.forEach(row => {
                    const [partNumber, orderQty, priority, batchId, batchQty, opSeq, opName, machine, person, setupStart, setupEnd, runStart, runEnd, timing, dueDate] = row;
                    
                    // Update machine and operator schedules
                    machineSchedule[machine] = new Date(runEnd);
                    operatorSchedule[person] = new Date(runEnd);
                    
                    results.push({
                        PartNumber: partNumber,
                        Order_Quantity: orderQty,
                        Priority: priority,
                        Batch_ID: batchId,
                        Batch_Qty: batchQty,
                        OperationSeq: opSeq,
                        OperationName: opName,
                        Machine: machine,
                        Person: person,
                        SetupStart: setupStart,
                        SetupEnd: setupEnd,
                        RunStart: runStart,
                        RunEnd: runEnd,
                        Timing: timing,
                        DueDate: dueDate
                    });
                });
            }
            return { rows: results, alerts };
        }

        function runSchedule() {
            if (savedOrders.length === 0) {
                alert('Please add at least one order before running the schedule');
                return;
            }

            document.getElementById('loadingIndicator').style.display = 'block';
            document.getElementById('resultsCard').style.display = 'none';

            // Simulate processing time
            setTimeout(() => {
                try {
                    scheduleResults = processOrders();
                    displayResults();
                    document.getElementById('exportBtn').disabled = false;
                    showAlert('Schedule generated successfully!', 'success');
                } catch (error) {
                    console.error('Scheduling error:', error);
                    showAlert('Error generating schedule: ' + error.message, 'error');
                } finally {
                    document.getElementById('loadingIndicator').style.display = 'none';
                }
            }, 1000);
        }

        function processOrders() {
            const results = [];
            const alerts = [];
            const machineSchedule = {}; // Track when each machine is available
            const operatorSchedule = {}; // Track operator availability per shift
            const operators = ["A", "B", "C", "D"];
            
            // Initialize machine and operator tracking
            const allMachines = ["VMC 1", "VMC 2", "VMC 3", "VMC 4", "VMC 5", "VMC 6", "VMC 7"];
            allMachines.forEach(machine => {
                machineSchedule[machine] = getNextShiftStart();
            });
            
            // Initialize operator schedules
            operators.forEach(op => {
                operatorSchedule[op] = getNextShiftStart();
            });

            // Sort orders by priority and due date
            const sortedOrders = [...savedOrders].sort((a, b) => {
                const priorityWeight = { Urgent: 4, High: 3, Normal: 2, Low: 1 };
                if (priorityWeight[a.priority] !== priorityWeight[b.priority]) {
                    return priorityWeight[b.priority] - priorityWeight[a.priority];
                }
                return new Date(a.dueDate) - new Date(b.dueDate);
            });

            sortedOrders.forEach(order => {
                // CRITICAL: Use ONLY pre-filtered operations from order submission
                // This ensures excluded operations never appear in results
                let operations = Array.isArray(order.filteredOperations) ? order.filteredOperations.slice() : [];
                
                // STRICT: Never rebuild from OP_MASTER here. If empty, skip this order with an alert.
                if (operations.length === 0) {
                    const msg = `No filtered operations present for ${order.partNumber}. Skipping this order to enforce strict filtering.`;
                    console.warn(msg);
                    alerts.push(msg);
                    return;
                }
                
                if (operations.length === 0) {
                    alerts.push(`No operations found for part number: ${order.partNumber}`);
                    return;
                }

                // STRICT ENFORCEMENT: Only process selected operations
                console.log(`SCHEDULING: Processing ${operations.length} operations for ${order.partNumber}:`, 
                    operations.map(op => `Op ${op.OperationSeq}: ${op.OperationName}`));
                console.log(`Order operationSeq setting: "${order.operationSeq}"`);
                
                // Final verification: ensure operations match selection
                if (order.operationSeq && order.operationSeq !== '') {
                    const selectedSeqs = order.operationSeq.split(',').map(seq => parseInt(seq.trim()));
                    const beforeCount = operations.length;
                    operations = operations.filter(op => selectedSeqs.includes(op.OperationSeq));
                    console.log(`STRICT FILTER: Reduced from ${beforeCount} to ${operations.length} operations`);
                    console.log(`FINAL OPERATIONS TO PROCESS:`, operations.map(op => `Op ${op.OperationSeq}`));
                }

                // Batch splitting by priority and due constraints
                const batches = splitOrderIntoBatches(order);
                batches.forEach((batch, idx) => {
                    const batchId = `${order.partNumber}-${idx + 1}`;
                    const batchOrder = { ...order, quantity: batch.qty };
                    const engineResult = runSchedulingInBrowser([batchOrder], operations);
                    const operationResults = engineResult.success ? engineResult.outputData.mainOutput.map(row => ({
                        OperationSeq: row[5],
                        OperationName: row[6],
                        Machine: row[7],
                        Person: row[8],
                        SetupStart: new Date(row[9]),
                        SetupEnd: new Date(row[10]),
                        RunStart: new Date(row[11]),
                        RunEnd: new Date(row[12]),
                        Timing: row[13],
                        actualRunEnd: new Date(row[12])
                    })) : [];

                    // Determine batch completion and due compliance
                    const lastOp = operationResults[operationResults.length - 1];
                    const batchCompletion = lastOp ? lastOp.RunEnd : null;
                    const due = new Date(order.dueDate);
                    const isOnTime = batchCompletion ? (new Date(batchCompletion).getTime() <= due.getTime() + (24*60*60*1000 - 1)) : true; // same-day due
                    const dueMark = isOnTime ? '✅' : '⚠️';
                    if (order.priority === 'Urgent' && !isOnTime && batchCompletion) {
                        const lateMs = new Date(batchCompletion).getTime() - due.getTime();
                        const lateHrs = Math.ceil(lateMs / 3600000);
                        alerts.push(`High Risk: ${order.partNumber} batch ${idx + 1} expected late by ~${lateHrs}h (due ${formatDate(order.dueDate)}).`);
                    }

                    operationResults.forEach(opResult => {
                        // Update resource schedules at each op
                        machineSchedule[opResult.Machine] = opResult.actualRunEnd;
                        operatorSchedule[opResult.Person] = opResult.actualRunEnd;

                        results.push({
                            PartNumber: order.partNumber,
                            Order_Quantity: order.quantity,
                            Priority: order.priority,
                            Batch_ID: batchId,
                            Batch_Qty: batch.qty,
                            OperationSeq: opResult.OperationSeq,
                            OperationName: opResult.OperationName,
                            Machine: opResult.Machine,
                            Person: opResult.Person,
                            SetupStart: formatDateTime(opResult.SetupStart),
                            SetupEnd: formatDateTime(opResult.SetupEnd),
                            RunStart: formatDateTime(opResult.RunStart),
                            RunEnd: formatDateTime(opResult.RunEnd),
                            Timing: opResult.Timing,
                            DueDate: `${formatDate(order.dueDate)} ${dueMark}`
                        });
                    });
                });
            });

            return { rows: results, alerts: alerts };
        }

        // Split total order quantity into batches based on priority
        function splitOrderIntoBatches(order) {
            const qty = Number(order.quantity) || 0;
            if (qty <= 0) return [];
            let parts = 1;
            switch ((order.priority || 'Normal')) {
                case 'Urgent': parts = Math.min(4, Math.max(1, qty)); break; // up to 4 smaller batches
                case 'High': parts = Math.min(3, Math.max(1, qty >= 3 ? 3 : qty)); break;
                case 'Normal': parts = Math.min(2, Math.max(1, qty >= 2 ? 2 : qty)); break;
                case 'Low': default: parts = 1; break;
            }
            const base = Math.floor(qty / parts);
            const rem = qty % parts;
            const batches = [];
            for (let i = 0; i < parts; i++) {
                batches.push({ qty: base + (i < rem ? 1 : 0) });
            }
            return batches;
        }

        function getNextShiftStart() {
            // Use Global Start Date-Time if set, otherwise fallback to current time
            const globalStartTime = getGlobalStartTime();
            const now = globalStartTime || new Date();
            
            // CRITICAL FIX: Respect Global Setup Window instead of hardcoded 06:00
            const setupWindow = parseSetupWindow(getSetupWindow());
            const setupStartHour = setupWindow.start;
            const setupEndHour = setupWindow.end;
            
            const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
            
            // Use actual setup window start time instead of hardcoded 06:00
            const setupWindowStart = new Date(today.getTime() + (setupStartHour * 60 * 60 * 1000));
            const setupWindowEnd = new Date(today.getTime() + (setupEndHour * 60 * 60 * 1000));
            const nextDaySetupStart = new Date(today.getTime() + (24 + setupStartHour) * 60 * 60 * 1000);
            
            console.log(`getNextShiftStart: Setup Window ${setupStartHour}:00-${setupEndHour}:00, Current: ${now.toISOString()}`);
            
            if (now < setupWindowStart) {
                console.log(`Before setup window, returning: ${setupWindowStart.toISOString()}`);
                return setupWindowStart;
            }
            if (now < setupWindowEnd) {
                console.log(`Within setup window, returning current time: ${now.toISOString()}`);
                return now;
            }
            console.log(`After setup window, returning next day: ${nextDaySetupStart.toISOString()}`);
            return nextDaySetupStart;
        }

        function calculateShiftAwareSchedule(machineAvailableTime, operatorAvailableTime, setupTime, runTime, orderSettings = null) {
            // CRITICAL FIX: Always use Global Start Time or current time, but FORCE into setup window
            const globalStartTime = getGlobalStartTime();
            const baseTime = globalStartTime ? globalStartTime.getTime() : Date.now();
            let startTime = new Date(Math.max(machineAvailableTime.getTime(), operatorAvailableTime.getTime(), baseTime));
            
            console.log('🚨 SCHEDULER START: Initial time before any adjustments:', startTime.toISOString());
            
            // MANDATORY HOLIDAY ENFORCEMENT: Must check holidays FIRST before any other logic
            const holidays = getHolidays();
            console.log(`🏖️ MANDATORY HOLIDAY CHECK: Found ${holidays.length} holidays`);
            
            if (holidays.length > 0) {
                // Check if start time conflicts with any holiday
                for (const holiday of holidays) {
                    console.log(`   Checking holiday: ${holiday.start.toISOString()} → ${holiday.end.toISOString()}`);
                    if (startTime >= holiday.start && startTime < holiday.end) {
                        console.log(`🚫 HOLIDAY CONFLICT DETECTED! Moving start time from ${startTime.toISOString()} to ${holiday.end.toISOString()}`);
                        startTime = new Date(holiday.end);
                        break;
                    }
                }
            }
            
            console.log('🏖️ POST-HOLIDAY start time:', startTime.toISOString());
            
            // MANDATORY BREAKDOWN ENFORCEMENT: Check machine breakdowns AFTER holidays
            // Note: We need machine ID to check breakdowns, but this function doesn't have it yet
            // Breakdown enforcement will be done in the operation-specific scheduling
            
            // LAYER 1: Setup Layer (People-Dependent) - HARD CONSTRAINT Setup Window Enforcement
            const setupWindowStr = orderSettings ? orderSettings.setupWindow : getSetupWindow();
            console.log('Getting setup window string:', setupWindowStr);
            const setupWindow = parseSetupWindow(setupWindowStr);
            
            // FORCE SETUP INTO WINDOW - NO EXCEPTIONS
            console.log('Original start time before enforcement:', startTime.toISOString());
            
            // STRICT ENFORCEMENT: If current time is outside setup window, FORCE to next valid window
            const currentHour = startTime.getHours();
            const currentMinutes = startTime.getMinutes();
            const currentTotalMinutes = currentHour * 60 + currentMinutes;
            const windowStartMinutes = setupWindow.start * 60;
            const windowEndMinutes = setupWindow.end * 60;
            
            console.log(`⚡ Setup Window Enforcement Check:`);
            console.log(`   Current time: ${currentHour}:${currentMinutes.toString().padStart(2, '0')} (${currentTotalMinutes} minutes)`);
            console.log(`   Setup Window: ${setupWindow.start}:00-${setupWindow.end}:00 (${windowStartMinutes}-${windowEndMinutes} minutes)`);
            
            if (currentTotalMinutes < windowStartMinutes) {
                // Before window - move to start of window (same day)
                startTime.setHours(setupWindow.start, 0, 0, 0);
                console.log('🔄 SHIFTED FORWARD to window start (before):', startTime.toISOString());
            } else if (currentTotalMinutes >= windowEndMinutes) {
                // After window - move to NEXT DAY's window start
                startTime.setDate(startTime.getDate() + 1);
                startTime.setHours(setupWindow.start, 0, 0, 0);
                console.log('🔄 SHIFTED to next day window start (after):', startTime.toISOString());
            } else {
                console.log('✅ Within setup window, keeping time:', startTime.toISOString());
            }
            
            let setupStart = new Date(startTime);
            
            // Step 2: MANDATORY HOLIDAY CHECK for entire setup duration
            console.log(`🔍 SETUP HOLIDAY CHECK: Validating setup from ${setupStart.toISOString()} for ${setupTime} minutes`);
            
            // Calculate setup end time
            let setupEnd = new Date(setupStart.getTime() + (setupTime * 60 * 1000));
            
            // Check if setup spans any holidays and adjust accordingly
            const setupHolidayResult = adjustOperationForHolidays(setupStart, setupEnd, 'SETUP');
            setupStart = setupHolidayResult.adjustedStart;
            setupEnd = setupHolidayResult.adjustedEnd;
            
            console.log(`🏖️ SETUP after holiday adjustment: ${setupStart.toISOString()} → ${setupEnd.toISOString()}`);
            
            // CRITICAL: Enforce setup window boundaries - setup MUST stay within people-dependent shifts
            const validatedSetup = enforceSetupWindowBoundaries(setupStart, setupTime, setupWindow);
            setupStart = validatedSetup.setupStart;
            setupEnd = validatedSetup.setupEnd;
            
            // Step 3: Ensure operators are available during setup time (only if needed)
            const setupShift = getSetupShift(setupStart, orderSettings?.shifts);
            if (!setupShift.hasOperators) {
                // Move to next available setup window with operators
                setupStart = getNextSetupWindow(setupStart, setupWindow, orderSettings?.shifts);
                // Re-validate after moving to next window
                const revalidatedSetup = validateSetupWithinWindowAndHolidays(setupStart, setupTime, setupWindow);
                setupStart = revalidatedSetup.setupStart;
                setupEnd = revalidatedSetup.setupEnd;
            }
            
            // LAYER 2: Production Layer with MANDATORY HOLIDAY ENFORCEMENT
            console.log(`🔍 RUN HOLIDAY CHECK: Validating run from ${setupEnd.toISOString()} for ${runTime} minutes`);
            
            // Calculate initial run end time
            let runStart = new Date(setupEnd);
            let runEnd = new Date(runStart.getTime() + (runTime * 60 * 1000));

            // MANDATORY: Check if run spans any holidays
            const runHolidayResult = adjustOperationForHolidays(runStart, runEnd, 'RUN');
            runStart = runHolidayResult.adjustedStart;
            runEnd = runHolidayResult.adjustedEnd;

            console.log(`🏖️ RUN after holiday adjustment: ${runStart.toISOString()} → ${runEnd.toISOString()}`);

            // ENFORCE Production Window (Machine-Dependent) using UI shifts
            const productionShifts = getProductionShiftsFromUI();
            const runDurationMinutes = Math.max(0, Math.round((runEnd.getTime() - runStart.getTime()) / 60000));
            const enforcedSchedule = calculateProductionWithShiftBoundaries(runStart, runDurationMinutes, productionShifts);
            const runSchedule = {
                runStart: enforcedSchedule.runStart,
                runEnd: enforcedSchedule.runEnd
            };
            
            // Calculate total timing including setup + production
            const totalElapsed = (runSchedule.runEnd.getTime() - setupStart.getTime()) / (1000 * 60);
            const actualWork = setupTime + runTime;
            const totalPausedTime = totalElapsed - actualWork;
            
            return {
                setupStart,
                setupEnd,
                runStart: runSchedule.runStart,
                runEnd: runSchedule.runEnd,
                timingDescription: `${formatDuration(totalElapsed)} (${formatDuration(actualWork)} Work)`
            };
        }

        function getSetupShift(time, shifts = null) {
            // Use actual shift timings from UI instead of hardcoded values
            const actualShifts = shifts || getShifts();
            const shift1 = parseShiftTime(actualShifts.shift1);
            const shift2 = parseShiftTime(actualShifts.shift2);
            const shift3 = parseShiftTime(actualShifts.shift3);
            
            const timeMinutes = time.getHours() * 60 + time.getMinutes();
            
            // Check Shift 1 (Morning)
            if (timeMinutes >= shift1.start && timeMinutes < shift1.end) {
                return { shift: 1, operators: ['A', 'B'], hasOperators: true, window: shift1 };
            }
            // Check Shift 2 (Afternoon)
            else if (timeMinutes >= shift2.start && timeMinutes < shift2.end) {
                return { shift: 2, operators: ['C', 'D'], hasOperators: true, window: shift2 };
            }
            // Check Shift 3 (Night) - handle overnight shifts
            else if (shift3.start > shift3.end) {
                // Overnight shift (e.g., 22:00-06:00)
                if (timeMinutes >= shift3.start || timeMinutes < shift3.end) {
                    return { shift: 3, operators: [], hasOperators: false, window: shift3 }; // Night shift - no setups by default
                }
            } else if (timeMinutes >= shift3.start && timeMinutes < shift3.end) {
                return { shift: 3, operators: [], hasOperators: false, window: shift3 };
            }
            
            // Outside all shifts
            return { shift: 0, operators: [], hasOperators: false, window: null };
        }

        function enforceSetupWindow(time, setupWindow) {
            const hour = time.getHours();
            const minute = time.getMinutes();
            
            console.log('Enforcing Setup Window:', {
                originalTime: time.toISOString(),
                hour: hour,
                minute: minute,
                setupWindow: setupWindow
            });
            
            // HARD CONSTRAINT: Setup can ONLY occur within Setup Window
            
            // If before setup window start, move to start of window (same day or next day)
            if (hour < setupWindow.start) {
                const newTime = new Date(time);
                newTime.setHours(setupWindow.start, 0, 0, 0);
                console.log('Moved to window start (before):', newTime.toISOString());
                return newTime;
            }
            
            // If at or after setup window end, move to NEXT DAY's window start
            if (hour >= setupWindow.end) {
                const nextDay = new Date(time);
                nextDay.setDate(nextDay.getDate() + 1);
                nextDay.setHours(setupWindow.start, 0, 0, 0);
                console.log('Moved to next day window start (after):', nextDay.toISOString());
                return nextDay;
            }
            
            // Within window, return as-is
            console.log('Within window, keeping time:', time.toISOString());
            return new Date(time);
        }

        function enforceSetupWindowBoundaries(setupStart, setupDuration, setupWindow) {
            let currentStart = new Date(setupStart);
            let remainingDuration = setupDuration;
            const segments = [];
            let totalPausedTime = 0;
            
            console.log(`🔧 ENFORCING Setup Window: ${setupWindow.start}:00-${setupWindow.end}:00 for ${setupDuration}min setup`);
            
            while (remainingDuration > 0) {
                // Force start time into valid window
                const currentHour = currentStart.getHours();
                const currentMinutes = currentStart.getMinutes();
                const currentTotalMinutes = currentHour * 60 + currentMinutes;
                const windowStartMinutes = setupWindow.start * 60;
                const windowEndMinutes = setupWindow.end * 60;
                
                // Push start time into window if outside
                if (currentTotalMinutes < windowStartMinutes) {
                    // Before window - move to start of window (same day)
                    currentStart.setHours(setupWindow.start, 0, 0, 0);
                    console.log(`⏰ Setup start pushed to window start: ${currentStart.toISOString()}`);
                } else if (currentTotalMinutes >= windowEndMinutes) {
                    // After window - move to NEXT DAY's window start
                    currentStart.setDate(currentStart.getDate() + 1);
                    currentStart.setHours(setupWindow.start, 0, 0, 0);
                    console.log(`⏰ Setup start pushed to next day window: ${currentStart.toISOString()}`);
                }
                
                // Calculate window end for this day
                const windowEnd = new Date(currentStart);
                windowEnd.setHours(setupWindow.end, 0, 0, 0);
                
                // Calculate how much time we can use in this window
                const timeUntilWindowEnd = (windowEnd.getTime() - currentStart.getTime()) / (1000 * 60);
                const timeToUse = Math.min(remainingDuration, timeUntilWindowEnd);
                
                const segmentEnd = new Date(currentStart.getTime() + timeToUse * 60000);
                segments.push({
                    start: new Date(currentStart),
                    end: segmentEnd,
                    duration: timeToUse
                });
                
                remainingDuration -= timeToUse;
                
                // If we need more time, move to next day's window
                if (remainingDuration > 0) {
                    const pauseStart = segmentEnd;
                    currentStart = new Date(currentStart);
                    currentStart.setDate(currentStart.getDate() + 1);
                    currentStart.setHours(setupWindow.start, 0, 0, 0);
                    
                    const pauseTime = (currentStart.getTime() - pauseStart.getTime()) / (1000 * 60);
                    totalPausedTime += pauseTime;
                    
                    console.log(`⏸️ Setup paused at ${pauseStart.toISOString()}, resumes at ${currentStart.toISOString()}`);
                }
            }
            
            const finalStart = segments[0].start;
            const finalEnd = segments[segments.length - 1].end;
            
            console.log(`✅ Setup enforced: ${finalStart.toISOString()} → ${finalEnd.toISOString()} (${segments.length} segments, ${totalPausedTime.toFixed(1)}min paused)`);
            
            return {
                setupStart: finalStart,
                setupEnd: finalEnd,
                segments: segments,
                totalPausedTime: totalPausedTime,
                isPaused: segments.length > 1
            };
        }
        
        function enforceSetupStartInWindow(setupStartTime, setupWindow) {
            const currentHour = setupStartTime.getHours();
            const currentMinutes = setupStartTime.getMinutes();
            const currentTotalMinutes = currentHour * 60 + currentMinutes;
            const windowStartMinutes = setupWindow.start * 60;
            const windowEndMinutes = setupWindow.end * 60;
            
            let adjustedStart = new Date(setupStartTime);
            
            if (currentTotalMinutes < windowStartMinutes) {
                // Before window - move to start of window (same day)
                adjustedStart.setHours(setupWindow.start, 0, 0, 0);
                console.log(`🔧 Setup start pushed from ${setupStartTime.toISOString()} to window start: ${adjustedStart.toISOString()}`);
            } else if (currentTotalMinutes >= windowEndMinutes) {
                // After window - move to NEXT DAY's window start
                adjustedStart.setDate(adjustedStart.getDate() + 1);
                adjustedStart.setHours(setupWindow.start, 0, 0, 0);
                console.log(`🔧 Setup start pushed from ${setupStartTime.toISOString()} to next day window: ${adjustedStart.toISOString()}`);
            }
            
            return adjustedStart;
        }
        
        function validateSetupWithinWindow(setupStart, setupDuration, setupWindow) {
            // Legacy function - redirect to new enforcer
            return enforceSetupWindowBoundaries(setupStart, setupDuration, setupWindow);
        }

        function getNextSetupWindow(currentTime, setupWindow, shifts = null) {
            // Find next available operator shift window
            const actualShifts = shifts || getShifts();
            const shift1 = parseShiftTime(actualShifts.shift1);
            const shift2 = parseShiftTime(actualShifts.shift2);
            
            const currentMinutes = currentTime.getHours() * 60 + currentTime.getMinutes();
            let nextShiftStart = null;
            
            // Check if we can start in Shift 1 today
            if (currentMinutes < shift1.start) {
                nextShiftStart = new Date(currentTime);
                nextShiftStart.setHours(Math.floor(shift1.start / 60), shift1.start % 60, 0, 0);
                return nextShiftStart;
            }
            // Check if we can start in Shift 2 today
            else if (currentMinutes < shift2.start) {
                nextShiftStart = new Date(currentTime);
                nextShiftStart.setHours(Math.floor(shift2.start / 60), shift2.start % 60, 0, 0);
                return nextShiftStart;
            }
            // Move to next day's Shift 1
            else {
                nextShiftStart = new Date(currentTime);
                nextShiftStart.setDate(nextShiftStart.getDate() + 1);
                nextShiftStart.setHours(Math.floor(shift1.start / 60), shift1.start % 60, 0, 0);
                return nextShiftStart;
            }
        }

        function alignSetupToOperatorShift(setupStartTime, setupDuration, orderSettings = null) {
            // Enforce Operator=1 rule: setup must be performed by runtime operators (A-D) inside their shift
            // BUT FIRST: Enforce Global Setup Window (People-Dependent) boundaries
            const setupWindowStr = orderSettings ? orderSettings.setupWindow : getSetupWindow();
            const setupWindow = parseSetupWindow(setupWindowStr);
            const windowAdjustedStart = enforceSetupStartInWindow(setupStartTime, setupWindow);
            
            const actualShifts = orderSettings?.shifts || getShifts();
            const shift1 = parseShiftTime(actualShifts.shift1);
            const shift2 = parseShiftTime(actualShifts.shift2);
            
            let currentTime = new Date(windowAdjustedStart);
            let remainingSetup = setupDuration;
            const segments = [];
            
            console.log(`Aligning setup to operator shifts - Start: ${currentTime.toISOString()}, Duration: ${setupDuration}min`);
            
            while (remainingSetup > 0) {
                const currentMinutes = currentTime.getHours() * 60 + currentTime.getMinutes();
                let currentShift = null;
                let shiftEndMinutes = null;
                
                // Determine which operator shift is active
                if (currentMinutes >= shift1.start && currentMinutes < shift1.end) {
                    currentShift = { name: 'Shift1', operators: ['A', 'B'], start: shift1.start, end: shift1.end };
                    shiftEndMinutes = shift1.end;
                } else if (currentMinutes >= shift2.start && currentMinutes < shift2.end) {
                    currentShift = { name: 'Shift2', operators: ['C', 'D'], start: shift2.start, end: shift2.end };
                    shiftEndMinutes = shift2.end;
                }
                
                if (!currentShift) {
                    // No valid operator shift - move to next available shift
                    console.log(`No operator shift active at ${currentTime.toISOString()}, moving to next shift`);
                    currentTime = getNextSetupWindow(currentTime, null, actualShifts);
                    continue;
                }
                
                // Calculate how much setup can be done in this shift
                const shiftEndTime = new Date(currentTime);
                shiftEndTime.setHours(Math.floor(shiftEndMinutes / 60), shiftEndMinutes % 60, 0, 0);
                const timeUntilShiftEnd = (shiftEndTime.getTime() - currentTime.getTime()) / (1000 * 60);
                const setupInThisShift = Math.min(remainingSetup, timeUntilShiftEnd);
                
                const segmentEnd = new Date(currentTime.getTime() + setupInThisShift * 60000);
                segments.push({
                    start: new Date(currentTime),
                    end: segmentEnd,
                    duration: setupInThisShift,
                    shift: currentShift.name,
                    operators: currentShift.operators
                });
                
                console.log(`Setup segment: ${currentTime.toISOString()} to ${segmentEnd.toISOString()} (${setupInThisShift}min) in ${currentShift.name}`);
                
                remainingSetup -= setupInThisShift;
                currentTime = segmentEnd;
                
                // If more setup needed, move to next shift
                if (remainingSetup > 0) {
                    currentTime = getNextSetupWindow(currentTime, null, actualShifts);
                }
            }
            
            const finalSetupStart = segments[0].start;
            const finalSetupEnd = segments[segments.length - 1].end;
            
            console.log(`Aligned setup complete: ${finalSetupStart.toISOString()} to ${finalSetupEnd.toISOString()}`);
            
            return {
                setupStart: finalSetupStart,
                setupEnd: finalSetupEnd,
                segments: segments,
                isPaused: segments.length > 1
            };
        }

        function getProductionShifts() {
            const productionWindow = getProductionWindow();
            const shifts = getShifts();
            
            switch (productionWindow) {
                case '24x7':
                    return [
                        { start: 0, end: 24 * 60, enabled: true, name: '24x7' } // 24x7 continuous
                    ];
                case '2-shift':
                    // Use actual shift1 + shift2 timings from UI
                    const shift1 = parseShiftTime(shifts.shift1);
                    const shift2 = parseShiftTime(shifts.shift2);
                    return [
                        { start: shift1.start, end: shift2.end, enabled: true, name: '2-shift' }
                    ];
                case '3-shift':
                    // Use actual shift timings from UI - all 3 shifts enabled
                    const s1 = parseShiftTime(shifts.shift1);
                    const s2 = parseShiftTime(shifts.shift2);
                    const s3 = parseShiftTime(shifts.shift3);
                    return [
                        { start: s1.start, end: s1.end, enabled: true, name: 'Shift1' },
                        { start: s2.start, end: s2.end, enabled: true, name: 'Shift2' },
                        { start: s3.start, end: s3.end, enabled: true, name: 'Shift3' }
                    ];
                case 'custom':
                    // Custom mode: check which shifts are enabled based on non-empty values
                    const customShifts = [];
                    if (shifts.shift1 && shifts.shift1.trim()) {
                        const cs1 = parseShiftTime(shifts.shift1);
                        customShifts.push({ start: cs1.start, end: cs1.end, enabled: true, name: 'Shift1' });
                    }
                    if (shifts.shift2 && shifts.shift2.trim()) {
                        const cs2 = parseShiftTime(shifts.shift2);
                        customShifts.push({ start: cs2.start, end: cs2.end, enabled: true, name: 'Shift2' });
                    }
                    if (shifts.shift3 && shifts.shift3.trim()) {
                        const cs3 = parseShiftTime(shifts.shift3);
                        customShifts.push({ start: cs3.start, end: cs3.end, enabled: true, name: 'Shift3' });
                    }
                    // If no custom shifts defined, fallback to 24x7
                    return customShifts.length > 0 ? customShifts : [{ start: 0, end: 24 * 60, enabled: true, name: '24x7' }];
                default:
                    return [
                        { start: 0, end: 24 * 60, enabled: true, name: 'default' }
                    ];
            }
        }

        function getProductionWindow() {
            const productionSelect = document.getElementById('productionWindow');
            return productionSelect ? productionSelect.value : '24x7';
        }

        // NEW: Read Production Window shifts directly from UI inputs
        function getProductionShiftsFromUI() {
            const s1 = document.getElementById('prodShift1')?.value || '06:00-14:00';
            const s2 = document.getElementById('prodShift2')?.value || '14:00-22:00';
            const s3 = document.getElementById('prodShift3')?.value || '22:00-06:00';
            const ps1 = parseShiftTime(s1);
            const ps2 = parseShiftTime(s2);
            const ps3 = parseShiftTime(s3);
            return [
                { start: ps1.start, end: ps1.end, enabled: true, name: 'Shift1' },
                { start: ps2.start, end: ps2.end, enabled: true, name: 'Shift2' },
                { start: ps3.start, end: ps3.end, enabled: true, name: 'Shift3' }
            ];
        }

        function calculateProductionWithShiftBoundaries(runStart, runTimeMinutes, productionShifts) {
            let currentTime = new Date(runStart);
            let remainingTime = runTimeMinutes;
            const segments = [];
            let totalPausedTime = 0;

            while (remainingTime > 0) {
                const currentShift = findCurrentProductionShift(currentTime, productionShifts);
                
                if (!currentShift) {
                    // No production allowed at this time, move to next shift
                    const nextShift = findNextProductionShift(currentTime, productionShifts);
                    const pauseTime = (nextShift.getTime() - currentTime.getTime()) / (1000 * 60);
                    totalPausedTime += pauseTime;
                    currentTime = nextShift;
                    continue;
                }

                // Calculate how much time we can run in this shift
                const shiftEndTime = getShiftEndTime(currentTime, currentShift);
                const timeUntilShiftEnd = (shiftEndTime.getTime() - currentTime.getTime()) / (1000 * 60);
                const timeToRun = Math.min(remainingTime, timeUntilShiftEnd);
                
                const segmentEnd = new Date(currentTime.getTime() + timeToRun * 60000);
                segments.push({
                    start: new Date(currentTime),
                    end: segmentEnd,
                    duration: timeToRun
                });

                remainingTime -= timeToRun;
                currentTime = segmentEnd;

                // If we need more time, move to next shift
                if (remainingTime > 0) {
                    const nextShift = findNextProductionShift(currentTime, productionShifts);
                    if (nextShift.getTime() > currentTime.getTime()) {
                        const pauseTime = (nextShift.getTime() - currentTime.getTime()) / (60 * 1000);
                        totalPausedTime += pauseTime;
                    }
                    currentTime = nextShift;
                }
            }

            const finalRunStart = segments.length > 0 ? segments[0].start : runStart;
            const finalRunEnd = segments[segments.length - 1].end;
            
            return {
                runStart: finalRunStart,
                runEnd: finalRunEnd,
                segments,
                totalPausedTime
            };
        }

        function findCurrentProductionShift(time, productionShifts) {
            const dayMinutes = time.getHours() * 60 + time.getMinutes();
            
            for (const shift of productionShifts) {
                if (shift.enabled) {
                    // Handle overnight shifts (e.g., 22:00-06:00)
                    if (shift.start > shift.end) {
                        if (dayMinutes >= shift.start || dayMinutes < shift.end) {
                            return shift;
                        }
                    } else {
                        if (dayMinutes >= shift.start && dayMinutes < shift.end) {
                            return shift;
                        }
                    }
                }
            }
            return null;
        }

        function findNextProductionShift(time, productionShifts) {
            const dayMinutes = time.getHours() * 60 + time.getMinutes();
            let nextShiftStart = null;
            let nextDay = false;

            // Find the next enabled shift
            for (const shift of productionShifts) {
                if (shift.enabled) {
                    if (shift.start > dayMinutes) {
                        if (!nextShiftStart || shift.start < nextShiftStart) {
                            nextShiftStart = shift.start;
                        }
                    }
                }
            }

            // If no shift found today, get first shift of next day
            if (!nextShiftStart) {
                for (const shift of productionShifts) {
                    if (shift.enabled) {
                        if (!nextShiftStart || shift.start < nextShiftStart) {
                            nextShiftStart = shift.start;
                            nextDay = true;
                        }
                    }
                }
            }

            const nextTime = new Date(time);
            if (nextDay) {
                nextTime.setDate(nextTime.getDate() + 1);
            }
            nextTime.setHours(Math.floor(nextShiftStart / 60), nextShiftStart % 60, 0, 0);
            return nextTime;
        }

        function getShiftEndTime(time, shift) {
            const endTime = new Date(time);
            
            // Handle overnight shifts
            if (shift.start > shift.end) {
                if (time.getHours() * 60 + time.getMinutes() >= shift.start) {
                    // We're in the first part of overnight shift, end is next day
                    endTime.setDate(endTime.getDate() + 1);
                }
            }
            
            endTime.setHours(Math.floor(shift.end / 60), shift.end % 60, 0, 0);
            return endTime;
        }

        function getCurrentProductionShift(time, productionWindow) {
            const hour = time.getHours();
            
            switch (productionWindow) {
                case '24x7':
                    return { isProductionAllowed: true, minutesUntilEnd: 24 * 60 }; // Always allowed
                    
                case '2-shift':
                    if (hour >= 6 && hour < 22) {
                        const minutesUntilEnd = (22 - hour) * 60 - time.getMinutes();
                        return { isProductionAllowed: true, minutesUntilEnd };
                    }
                    return { isProductionAllowed: false, minutesUntilEnd: 0 };
                    
                case '3-shift':
                    // 3 shifts with boundaries: 06:00-14:00, 14:00-22:00, 22:00-06:00
                    let shiftEnd;
                    if (hour >= 6 && hour < 14) {
                        shiftEnd = 14;
                    } else if (hour >= 14 && hour < 22) {
                        shiftEnd = 22;
                    } else {
                        shiftEnd = hour < 6 ? 6 : 6 + 24; // Next day 06:00
                    }
                    const minutesUntilEnd = (shiftEnd - hour) * 60 - time.getMinutes();
                    return { isProductionAllowed: true, minutesUntilEnd };
                    
                default:
                    return { isProductionAllowed: true, minutesUntilEnd: 24 * 60 };
            }
        }

        function getNextProductionWindow(currentTime, productionWindow) {
            const hour = currentTime.getHours();
            const nextWindow = new Date(currentTime);
            
            switch (productionWindow) {
                case '24x7':
                    return currentTime; // Always available
                    
                case '2-shift':
                    if (hour >= 22 || hour < 6) {
                        // Move to next day 06:00
                        nextWindow.setDate(nextWindow.getDate() + (hour >= 22 ? 1 : 0));
                        nextWindow.setHours(6, 0, 0, 0);
                    }
                    return nextWindow;
                    
                case '3-shift':
                    // Move to next shift boundary
                    if (hour >= 6 && hour < 14) {
                        nextWindow.setHours(14, 0, 0, 0);
                    } else if (hour >= 14 && hour < 22) {
                        nextWindow.setHours(22, 0, 0, 0);
                    } else {
                        nextWindow.setDate(nextWindow.getDate() + 1);
                        nextWindow.setHours(6, 0, 0, 0);
                    }
                    return nextWindow;
                    
                default:
                    return currentTime;
            }
        }

        function alignToSetupWindow(time, setupWindow) {
            const hour = time.getHours();
            const date = new Date(time.getFullYear(), time.getMonth(), time.getDate());
            
            if (hour < setupWindow.start) {
                // Before window, move to start
                return new Date(date.getTime() + (setupWindow.start * 60 * 60 * 1000));
            } else if (hour >= setupWindow.end) {
                // After window, move to next day start
                return new Date(date.getTime() + (24 + setupWindow.start) * 60 * 60 * 1000);
            }
            return time; // Within window
        }

        // Scheduling functions moved to x10-browser.js engine

        function formatTiming(totalElapsedMs, pausedTimeMinutes) {
            const totalMinutes = Math.floor(totalElapsedMs / (60 * 1000));
            const days = Math.floor(totalMinutes / (24 * 60));
            const hours = Math.floor((totalMinutes % (24 * 60)) / 60);
            const minutes = totalMinutes % 60;
            
            let result = "";
            if (days > 0) result += `${days}d `;
            if (hours > 0) result += `${hours}h `;
            if (minutes > 0) result += `${minutes}m`;
            
            if (pausedTimeMinutes > 0) {
                const pausedHours = Math.floor(pausedTimeMinutes / 60);
                result += ` (paused ${pausedHours}h due to shift gaps)`;
            }
            
            return result.trim();
        }

        function formatDateTime(date) {
            if (!date || !(date instanceof Date)) {
                console.error('Invalid date passed to formatDateTime:', date);
                return 'Invalid Date';
            }
            
            // Force local timezone display instead of UTC
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            
            const formatted = `${year}-${month}-${day} ${hours}:${minutes}`;
            console.log('Formatting date:', date.toISOString(), '→', formatted);
            return formatted;
        }

        function formatDate(dateString) {
            return new Date(dateString).toISOString().slice(0, 10);
        }

        function formatDuration(minutes) {
            if (minutes < 60) {
                return `${Math.round(minutes)}M`;
            }
            
            const totalMinutes = Math.round(minutes);
            const days = Math.floor(totalMinutes / (24 * 60));
            const hours = Math.floor((totalMinutes % (24 * 60)) / 60);
            const mins = totalMinutes % 60;
            
            let result = '';
            if (days > 0) result += `${days}D `;
            if (hours > 0) result += `${hours}H `;
            if (mins > 0) result += `${mins}M`;
            
            return result.trim() || '0M';
        }

        function getBreakdownMachines() {
            const select = document.getElementById('breakdownMachines');
            if (!select) return [];
            return Array.from(select.selectedOptions).map(option => option.value);
        }

        function getBreakdownDateTime() {
            const input = document.getElementById('breakdownDateTime');
            return input ? input.value : '';
        }

        function getStartDateTime() {
            const input = document.getElementById('startDateTime');
            // Only construct a Date if there's a non-empty value
            if (input && input.value) {
                const d = new Date(input.value);
                if (!isNaN(d.getTime())) {
                    return d;
                }
                console.warn('Invalid Global Start Date-Time value, falling back to system time:', input.value);
            }
            return new Date();
        }

        function getGlobalStartTime() {
            // Get the Global Start Date-Time from advanced settings
            const input = document.getElementById('startDateTime');
            if (input && input.value) {
                const globalTime = new Date(input.value);
                if (!isNaN(globalTime.getTime())) {
                    console.log('Using Global Start Date-Time as T0:', globalTime.toISOString());
                    return globalTime;
                }
                console.warn('Global Start Date-Time is invalid, ignoring:', input.value);
            }
            console.log('No valid Global Start Date-Time set, using system current time');
            return null;
        }

        function getHolidays() {
            // Return saved holidays in the format expected by scheduler
            console.log('getHolidays() called - savedHolidays:', savedHolidays);
            
            const formattedHolidays = savedHolidays.map(holiday => {
                const startDate = new Date(holiday.startDateTime);
                const endDate = new Date(holiday.endDateTime);
                
                console.log(`Converting holiday: ${holiday.startDateTime} → ${startDate.toISOString()}, ${holiday.endDateTime} → ${endDate.toISOString()}`);
                
                return {
                    start: startDate,
                    end: endDate,
                    reason: holiday.reason || 'Holiday',
                    type: holiday.type
                };
            });
            
            console.log('Formatted holidays for scheduler:', formattedHolidays);
            return formattedHolidays;
        }
        
        function addHoliday() {
            const startInput = document.getElementById('holidayStart');
            const endInput = document.getElementById('holidayEnd');
            const reasonInput = document.getElementById('holidayReason');
            
            if (!startInput.value || !endInput.value) {
                alert('Please select both start and end date/time for the holiday.');
                return;
            }
            
            const startDate = new Date(startInput.value);
            const endDate = new Date(endInput.value);
            
            if (startDate >= endDate) {
                alert('End date/time must be after start date/time.');
                return;
            }
            
            const holiday = {
                id: editingHolidayId || Date.now(),
                startDateTime: startInput.value,
                endDateTime: endInput.value,
                reason: reasonInput.value || 'Holiday',
                type: calculateHolidayType(startDate, endDate)
            };
            
            if (editingHolidayId) {
                // Update existing holiday
                const index = savedHolidays.findIndex(h => h.id === editingHolidayId);
                if (index !== -1) {
                    savedHolidays[index] = holiday;
                }
                editingHolidayId = null;
            } else {
                // Add new holiday
                savedHolidays.push(holiday);
            }
            
            // Clear inputs
            startInput.value = '';
            endInput.value = '';
            reasonInput.value = '';
            
            // Merge overlapping holidays
            mergeOverlappingHolidays();
            
            // Update display
            updateHolidayTable();
            
            // Debug: Log current holidays after save
            console.log('Holiday saved - Current savedHolidays:', savedHolidays);
            
            showAlert('Holiday saved successfully!', 'success');
        }
        
        function calculateHolidayType(startDate, endDate) {
            const duration = (endDate - startDate) / (1000 * 60 * 60); // hours
            const startOfDay = new Date(startDate);
            startOfDay.setHours(0, 0, 0, 0);
            const endOfDay = new Date(startDate);
            endOfDay.setHours(23, 59, 59, 999);
            
            if (duration >= 24 || (startDate <= startOfDay && endDate >= endOfDay)) {
                return 'Full-Day';
            }
            return 'Partial';
        }
        
        function mergeOverlappingHolidays() {
            if (savedHolidays.length <= 1) return;
            
            // Sort holidays by start time
            savedHolidays.sort((a, b) => new Date(a.startDateTime) - new Date(b.startDateTime));
            
            const merged = [];
            let current = savedHolidays[0];
            
            for (let i = 1; i < savedHolidays.length; i++) {
                const next = savedHolidays[i];
                const currentEnd = new Date(current.endDateTime);
                const nextStart = new Date(next.startDateTime);
                
                if (currentEnd >= nextStart) {
                    // Overlapping - merge them
                    const nextEnd = new Date(next.endDateTime);
                    if (nextEnd > currentEnd) {
                        current.endDateTime = next.endDateTime;
                    }
                    current.reason = current.reason + (next.reason !== current.reason ? `, ${next.reason}` : '');
                    current.type = calculateHolidayType(new Date(current.startDateTime), new Date(current.endDateTime));
                } else {
                    merged.push(current);
                    current = next;
                }
            }
            merged.push(current);
            
            savedHolidays = merged;
        }
        
        function updateHolidayTable() {
            const tbody = document.getElementById('holidayTableBody');
            
            if (savedHolidays.length === 0) {
                tbody.innerHTML = '<tr><td colspan="5" style="text-align: center; color: #888;">No holidays added yet</td></tr>';
                return;
            }
            
            tbody.innerHTML = savedHolidays.map(holiday => {
                const startDate = new Date(holiday.startDateTime);
                const endDate = new Date(holiday.endDateTime);
                
                return `
                    <tr>
                        <td>${startDate.toLocaleString()}</td>
                        <td>${endDate.toLocaleString()}</td>
                        <td><span class="badge ${holiday.type === 'Full-Day' ? 'badge-primary' : 'badge-secondary'}">${holiday.type}</span></td>
                        <td>${holiday.reason}</td>
                        <td>
                            <div class="holiday-actions">
                                <button class="btn-icon btn-edit" onclick="editHoliday(${holiday.id})" title="Edit Holiday">✏️</button>
                                <button class="btn-icon btn-delete" onclick="deleteHoliday(${holiday.id})" title="Delete Holiday">🗑️</button>
                            </div>
                        </td>
                    </tr>
                `;
            }).join('');
        }
        
        function editHoliday(holidayId) {
            const holiday = savedHolidays.find(h => h.id === holidayId);
            if (!holiday) return;
            
            document.getElementById('holidayStart').value = holiday.startDateTime;
            document.getElementById('holidayEnd').value = holiday.endDateTime;
            document.getElementById('holidayReason').value = holiday.reason;
            
            editingHolidayId = holidayId;
            
            // Scroll to input section
            document.getElementById('holidayStart').scrollIntoView({ behavior: 'smooth' });
        }
        
        function deleteHoliday(holidayId) {
            console.log('Delete holiday called with ID:', holidayId);
            console.log('Current savedHolidays:', savedHolidays);
            
            if (confirm('Are you sure you want to delete this holiday?')) {
                const beforeCount = savedHolidays.length;
                savedHolidays = savedHolidays.filter(h => h.id !== holidayId);
                const afterCount = savedHolidays.length;
                
                console.log(`Deleted holiday. Before: ${beforeCount}, After: ${afterCount}`);
                
                updateHolidayTable();
                showAlert('Holiday deleted successfully!', 'success');
            }
        }
        
        // Machine Breakdown Management Functions
        function addBreakdown() {
            const startInput = document.getElementById('breakdownStart');
            const endInput = document.getElementById('breakdownEnd');
            const reasonInput = document.getElementById('breakdownReason');
            
            // Get selected machines
            const checkboxes = document.querySelectorAll('#machineCheckboxGroup input[type="checkbox"]:checked');
            const selectedMachines = Array.from(checkboxes).map(cb => cb.value);
            
            if (selectedMachines.length === 0) {
                alert('Please select at least one machine.');
                return;
            }
            
            if (!startInput.value || !endInput.value) {
                alert('Please select both start and end date/time for the breakdown.');
                startInput.focus();
                return;
            }
            
            // Validate datetime inputs
            if (!startInput.checkValidity() || !endInput.checkValidity()) {
                alert('Please enter valid date and time values.');
                return;
            }
            
            const startDate = new Date(startInput.value);
            const endDate = new Date(endInput.value);
            
            if (startDate >= endDate) {
                alert('End date/time must be after start date/time.');
                return;
            }
            
            const breakdown = {
                id: editingBreakdownId || Date.now(),
                machines: selectedMachines,
                startDateTime: startInput.value,
                endDateTime: endInput.value,
                reason: reasonInput.value || 'Machine Breakdown',
                duration: (endDate - startDate) / (1000 * 60 * 60) // hours
            };
            
            if (editingBreakdownId) {
                // Update existing breakdown
                const index = savedBreakdowns.findIndex(b => b.id === editingBreakdownId);
                if (index !== -1) {
                    savedBreakdowns[index] = breakdown;
                }
                editingBreakdownId = null;
            } else {
                // Add new breakdown
                savedBreakdowns.push(breakdown);
            }
            
            // Clear inputs
            startInput.value = '';
            endInput.value = '';
            reasonInput.value = '';
            checkboxes.forEach(cb => cb.checked = false);
            
            // Merge overlapping breakdowns for same machines
            mergeOverlappingBreakdowns();
            
            // Update display
            updateBreakdownTable();
            
            console.log('Breakdown saved - Current savedBreakdowns:', savedBreakdowns);
            showAlert('Machine breakdown saved successfully!', 'success');
        }
        
        function mergeOverlappingBreakdowns() {
            if (savedBreakdowns.length <= 1) return;
            
            // Group breakdowns by machine combinations
            const machineGroups = {};
            
            savedBreakdowns.forEach(breakdown => {
                const machineKey = breakdown.machines.sort().join(',');
                if (!machineGroups[machineKey]) {
                    machineGroups[machineKey] = [];
                }
                machineGroups[machineKey].push(breakdown);
            });
            
            // Merge overlapping breakdowns within each machine group
            const merged = [];
            
            Object.values(machineGroups).forEach(group => {
                if (group.length === 1) {
                    merged.push(group[0]);
                    return;
                }
                
                // Sort by start time
                group.sort((a, b) => new Date(a.startDateTime) - new Date(b.startDateTime));
                
                let current = group[0];
                
                for (let i = 1; i < group.length; i++) {
                    const next = group[i];
                    const currentEnd = new Date(current.endDateTime);
                    const nextStart = new Date(next.startDateTime);
                    
                    if (currentEnd >= nextStart) {
                        // Overlapping - merge them
                        const nextEnd = new Date(next.endDateTime);
                        if (nextEnd > currentEnd) {
                            current.endDateTime = next.endDateTime;
                        }
                        current.reason = current.reason + (next.reason !== current.reason ? `, ${next.reason}` : '');
                        current.duration = (new Date(current.endDateTime) - new Date(current.startDateTime)) / (1000 * 60 * 60);
                    } else {
                        merged.push(current);
                        current = next;
                    }
                }
                merged.push(current);
            });
            
            savedBreakdowns = merged;
        }
        
        function updateBreakdownTable() {
            const tbody = document.getElementById('breakdownTableBody');
            
            if (savedBreakdowns.length === 0) {
                tbody.innerHTML = '<tr><td colspan="5" style="text-align: center; color: #888;">No breakdowns added yet</td></tr>';
                return;
            }
            
            tbody.innerHTML = savedBreakdowns.map(breakdown => {
                const startDate = new Date(breakdown.startDateTime);
                const endDate = new Date(breakdown.endDateTime);
                
                const machineList = breakdown.machines.map(machine => 
                    `<span class="machine-tag">${machine}</span>`
                ).join(' ');
                
                return `
                    <tr>
                        <td><div class="machine-list">${machineList}</div></td>
                        <td>${startDate.toLocaleString()}</td>
                        <td>${endDate.toLocaleString()}</td>
                        <td>${breakdown.reason}</td>
                        <td>
                            <div class="holiday-actions">
                                <button class="btn-icon btn-edit" onclick="editBreakdown(${breakdown.id})" title="Edit Breakdown">✏️</button>
                                <button class="btn-icon btn-delete" onclick="deleteBreakdown(${breakdown.id})" title="Delete Breakdown">🗑️</button>
                            </div>
                        </td>
                    </tr>
                `;
            }).join('');
        }
        
        function editBreakdown(breakdownId) {
            const breakdown = savedBreakdowns.find(b => b.id === breakdownId);
            if (!breakdown) return;
            
            document.getElementById('breakdownStart').value = breakdown.startDateTime;
            document.getElementById('breakdownEnd').value = breakdown.endDateTime;
            document.getElementById('breakdownReason').value = breakdown.reason;
            
            // Select the machines
            const checkboxes = document.querySelectorAll('#machineCheckboxGroup input[type="checkbox"]');
            checkboxes.forEach(cb => {
                cb.checked = breakdown.machines.includes(cb.value);
            });
            
            editingBreakdownId = breakdownId;
            
            // Scroll to input section
            document.getElementById('breakdownStart').scrollIntoView({ behavior: 'smooth' });
        }
        
        function deleteBreakdown(breakdownId) {
            console.log('Delete breakdown called with ID:', breakdownId);
            console.log('Current savedBreakdowns:', savedBreakdowns);
            
            if (confirm('Are you sure you want to delete this machine breakdown?')) {
                const beforeCount = savedBreakdowns.length;
                savedBreakdowns = savedBreakdowns.filter(b => b.id !== breakdownId);
                const afterCount = savedBreakdowns.length;
                
                console.log(`Deleted breakdown. Before: ${beforeCount}, After: ${afterCount}`);
                
                updateBreakdownTable();
                showAlert('Machine breakdown deleted successfully!', 'success');
            }
        }
        
        function getBreakdowns() {
            // Return saved breakdowns in the format expected by scheduler
            console.log('getBreakdowns() called - savedBreakdowns:', savedBreakdowns);
            
            const formattedBreakdowns = savedBreakdowns.map(breakdown => {
                const startDate = new Date(breakdown.startDateTime);
                const endDate = new Date(breakdown.endDateTime);
                
                console.log(`Converting breakdown: ${breakdown.startDateTime} → ${startDate.toISOString()}, ${breakdown.endDateTime} → ${endDate.toISOString()}`);
                
                return {
                    machines: breakdown.machines,
                    start: startDate,
                    end: endDate,
                    reason: breakdown.reason || 'Machine Breakdown',
                    duration: breakdown.duration
                };
            });
            
            console.log('Formatted breakdowns for scheduler:', formattedBreakdowns);
            return formattedBreakdowns;
        }
        
        // Machine Breakdown enforcement functions for scheduler
        function adjustOperationForBreakdowns(operationStart, operationEnd, machineId, operationType) {
            const breakdowns = getBreakdowns();
            console.log(`🔧 ${operationType} BREAKDOWN ENFORCEMENT: Checking ${breakdowns.length} breakdowns for machine ${machineId} operation ${operationStart.toISOString()} → ${operationEnd.toISOString()}`);
            
            if (breakdowns.length === 0) {
                console.log(`✅ No breakdowns found, ${operationType} proceeds normally`);
                return {
                    adjustedStart: operationStart,
                    adjustedEnd: operationEnd,
                    breakdownPauses: []
                };
            }
            
            // Filter breakdowns that affect this machine
            const relevantBreakdowns = breakdowns.filter(breakdown => 
                breakdown.machines.includes(machineId)
            );
            
            console.log(`   Found ${relevantBreakdowns.length} breakdowns affecting machine ${machineId}`);
            
            if (relevantBreakdowns.length === 0) {
                console.log(`✅ No breakdowns affect machine ${machineId}, ${operationType} proceeds normally`);
                return {
                    adjustedStart: operationStart,
                    adjustedEnd: operationEnd,
                    breakdownPauses: []
                };
            }
            
            let adjustedStart = new Date(operationStart);
            let adjustedEnd = new Date(operationEnd);
            const breakdownPauses = [];
            
            // Check each relevant breakdown for conflicts
            for (const breakdown of relevantBreakdowns) {
                console.log(`   Checking breakdown: ${breakdown.start.toISOString()} → ${breakdown.end.toISOString()} (${breakdown.reason})`);
                
                // Case 1: Operation starts during breakdown
                if (adjustedStart >= breakdown.start && adjustedStart < breakdown.end) {
                    console.log(`🚫 ${operationType} START CONFLICT: Operation starts during breakdown, moving to ${breakdown.end.toISOString()}`);
                    const breakdownDelay = breakdown.end.getTime() - adjustedStart.getTime();
                    adjustedStart = new Date(breakdown.end);
                    adjustedEnd = new Date(adjustedEnd.getTime() + breakdownDelay);
                    breakdownPauses.push({
                        reason: breakdown.reason,
                        pauseStart: breakdown.start,
                        pauseEnd: breakdown.end,
                        delayMinutes: breakdownDelay / (1000 * 60),
                        machines: breakdown.machines
                    });
                }
                // Case 2: Operation spans across breakdown (starts before, ends after)
                else if (adjustedStart < breakdown.start && adjustedEnd > breakdown.start) {
                    console.log(`🚫 ${operationType} SPAN CONFLICT: Operation spans breakdown, adding pause from ${breakdown.start.toISOString()} to ${breakdown.end.toISOString()}`);
                    const breakdownDuration = breakdown.end.getTime() - breakdown.start.getTime();
                    adjustedEnd = new Date(adjustedEnd.getTime() + breakdownDuration);
                    breakdownPauses.push({
                        reason: breakdown.reason,
                        pauseStart: breakdown.start,
                        pauseEnd: breakdown.end,
                        delayMinutes: breakdownDuration / (1000 * 60),
                        machines: breakdown.machines
                    });
                }
            }
            
            console.log(`🔧 ${operationType} BREAKDOWN RESULT: ${operationStart.toISOString()} → ${adjustedStart.toISOString()} to ${adjustedEnd.toISOString()}`);
            
            return {
                adjustedStart,
                adjustedEnd,
                breakdownPauses
            };
        }
        
        function adjustTimeForBreakdowns(startTime, machineId) {
            const breakdowns = getBreakdowns();
            console.log(`🔍 BREAKDOWN ENFORCEMENT: Checking ${breakdowns.length} breakdowns for machine ${machineId} time ${startTime.toISOString()}`);
            
            if (breakdowns.length === 0) {
                console.log('❌ No breakdowns found, no adjustment needed');
                return startTime;
            }
            
            // Filter breakdowns that affect this machine
            const relevantBreakdowns = breakdowns.filter(breakdown => 
                breakdown.machines.includes(machineId)
            );
            
            if (relevantBreakdowns.length === 0) {
                console.log(`❌ No breakdowns affect machine ${machineId}, no adjustment needed`);
                return startTime;
            }
            
            let adjustedTime = new Date(startTime);
            
            for (const breakdown of relevantBreakdowns) {
                if (adjustedTime >= breakdown.start && adjustedTime < breakdown.end) {
                    console.log(`🚫 Time ${adjustedTime.toISOString()} falls within breakdown ${breakdown.start.toISOString()} → ${breakdown.end.toISOString()}, moving to ${breakdown.end.toISOString()}`);
                    adjustedTime = new Date(breakdown.end);
                }
            }
            
            if (adjustedTime.getTime() !== startTime.getTime()) {
                console.log(`🔧 BREAKDOWN ADJUSTMENT: ${startTime.toISOString()} → ${adjustedTime.toISOString()}`);
            } else {
                console.log('✅ No breakdown adjustment needed');
            }
            
            return adjustedTime;
        }
        
        // Holiday enforcement functions for scheduler
        function adjustTimeForHolidays(startTime) {
            const holidays = getHolidays();
            console.log(`🔍 HOLIDAY ENFORCEMENT: Checking ${holidays.length} holidays for time ${startTime.toISOString()}`);
            
            if (holidays.length === 0) {
                console.log('❌ No holidays found, no adjustment needed');
                return startTime;
            }
            
            // Log all holidays for debugging
            holidays.forEach((holiday, index) => {
                console.log(`   Holiday ${index + 1}: ${holiday.start.toISOString()} → ${holiday.end.toISOString()} (${holiday.reason})`);
            });
            
            let adjustedTime = new Date(startTime);
            
            for (const holiday of holidays) {
                const isInHoliday = adjustedTime >= holiday.start && adjustedTime < holiday.end;
                console.log(`   Checking if ${adjustedTime.toISOString()} is in holiday ${holiday.start.toISOString()} → ${holiday.end.toISOString()}: ${isInHoliday}`);
                
                if (isInHoliday) {
                    // Time falls during holiday, move to end of holiday
                    const originalTime = adjustedTime.toISOString();
                    adjustedTime = new Date(holiday.end);
                    console.log(`🚫 HOLIDAY CONFLICT! Moved time from ${originalTime} to ${adjustedTime.toISOString()} (after ${holiday.reason})`);
                    
                    // Check if new time falls in another holiday (recursive)
                    return adjustTimeForHolidays(adjustedTime);
                }
            }
            
            console.log(`✅ No holiday conflicts found, keeping time: ${adjustedTime.toISOString()}`);
            return adjustedTime;
        }
        
        function isTimeInHoliday(time) {
            const holidays = getHolidays();
            return holidays.some(holiday => time >= holiday.start && time < holiday.end);
        }
        
        function getNextNonHolidayTime(time) {
            const holidays = getHolidays();
            let nextTime = new Date(time);
            
            for (const holiday of holidays) {
                if (nextTime >= holiday.start && nextTime < holiday.end) {
                    nextTime = new Date(holiday.end);
                    // Recursively check if new time falls in another holiday
                    return getNextNonHolidayTime(nextTime);
                }
            }
            
            return nextTime;
        }
        
        function validateSetupWithinWindowAndHolidays(setupStart, setupDuration, setupWindow) {
            let currentStart = new Date(setupStart);
            let remainingDuration = setupDuration;
            const segments = [];
            
            while (remainingDuration > 0) {
                // Adjust for holidays first
                currentStart = adjustTimeForHolidays(currentStart);
                
                // Then validate within setup window
                const windowValidated = validateSetupWithinWindow(currentStart, remainingDuration, setupWindow);
                
                // Check if any part of this segment overlaps with holidays
                const segmentEnd = new Date(windowValidated.setupEnd);
                const holidays = getHolidays();
                
                let segmentStart = new Date(windowValidated.setupStart);
                let segmentDuration = (segmentEnd - segmentStart) / (1000 * 60);
                
                // Find if holiday interrupts this segment
                let holidayInterruption = null;
                for (const holiday of holidays) {
                    if (holiday.start > segmentStart && holiday.start < segmentEnd) {
                        holidayInterruption = holiday;
                        break;
                    }
                }
                
                if (holidayInterruption) {
                    // Split segment at holiday start
                    const durationBeforeHoliday = (holidayInterruption.start - segmentStart) / (1000 * 60);
                    segments.push({
                        start: segmentStart,
                        end: new Date(holidayInterruption.start),
                        duration: durationBeforeHoliday
                    });
                    
                    remainingDuration -= durationBeforeHoliday;
                    currentStart = new Date(holidayInterruption.end);
                } else {
                    // No holiday interruption, use the whole segment
                    segments.push({
                        start: segmentStart,
                        end: segmentEnd,
                        duration: segmentDuration
                    });
                    remainingDuration = 0;
                }
            }
            
            return {
                setupStart: segments[0].start,
                setupEnd: segments[segments.length - 1].end,
                segments: segments
            };
        }
        
        // NEW MANDATORY HOLIDAY ENFORCEMENT FUNCTION
        function adjustOperationForHolidays(operationStart, operationEnd, operationType) {
            const holidays = getHolidays();
            console.log(`🔍 ${operationType} HOLIDAY ENFORCEMENT: Checking ${holidays.length} holidays for operation ${operationStart.toISOString()} → ${operationEnd.toISOString()}`);
            
            if (holidays.length === 0) {
                console.log(`✅ No holidays found, ${operationType} proceeds normally`);
                return {
                    adjustedStart: operationStart,
                    adjustedEnd: operationEnd,
                    holidayPauses: []
                };
            }
            
            let adjustedStart = new Date(operationStart);
            let adjustedEnd = new Date(operationEnd);
            const holidayPauses = [];
            
            // Check each holiday for conflicts
            for (const holiday of holidays) {
                console.log(`   Checking holiday: ${holiday.start.toISOString()} → ${holiday.end.toISOString()} (${holiday.reason})`);
                
                // Case 1: Operation starts during holiday
                if (adjustedStart >= holiday.start && adjustedStart < holiday.end) {
                    console.log(`🚫 ${operationType} START CONFLICT: Operation starts during holiday, moving to ${holiday.end.toISOString()}`);
                    const holidayDelay = holiday.end.getTime() - adjustedStart.getTime();
                    adjustedStart = new Date(holiday.end);
                    adjustedEnd = new Date(adjustedEnd.getTime() + holidayDelay);
                    holidayPauses.push({
                        reason: holiday.reason,
                        pauseStart: holiday.start,
                        pauseEnd: holiday.end,
                        delayMinutes: holidayDelay / (1000 * 60)
                    });
                }
                // Case 2: Operation spans across holiday (starts before, ends after)
                else if (adjustedStart < holiday.start && adjustedEnd > holiday.start) {
                    console.log(`🚫 ${operationType} SPAN CONFLICT: Operation spans holiday, adding pause from ${holiday.start.toISOString()} to ${holiday.end.toISOString()}`);
                    const holidayDuration = holiday.end.getTime() - holiday.start.getTime();
                    adjustedEnd = new Date(adjustedEnd.getTime() + holidayDuration);
                    holidayPauses.push({
                        reason: holiday.reason,
                        pauseStart: holiday.start,
                        pauseEnd: holiday.end,
                        delayMinutes: holidayDuration / (1000 * 60)
                    });
                }
            }
            
            console.log(`🏖️ ${operationType} HOLIDAY RESULT: ${operationStart.toISOString()} → ${adjustedStart.toISOString()} to ${adjustedEnd.toISOString()}`);
            if (holidayPauses.length > 0) {
                console.log(`   Holiday pauses added:`, holidayPauses);
            }
            
            return {
                adjustedStart: adjustedStart,
                adjustedEnd: adjustedEnd,
                holidayPauses: holidayPauses
            };
        }

        function getSetupWindow() {
            const input = document.getElementById('setupAvailabilityWindow');
            if (input && input.value && input.value.trim() !== '') {
                console.log('✅ Using UI setup window value:', input.value);
                return input.value.trim();
            }
            
            // Fallback to advancedSettings if UI is empty
            if (advancedSettings && advancedSettings.setupAvailabilityWindow) {
                console.log('⚠️ UI setup window empty, using advancedSettings fallback:', advancedSettings.setupAvailabilityWindow);
                return advancedSettings.setupAvailabilityWindow;
            }
            
            // Last resort fallback - improved default
            console.error('❌ No setup window found in UI or settings, using hardcoded fallback: 06:00-22:00');
            return '06:00-22:00';
        }

        function getShifts() {
            return {
                shift1: document.getElementById('shift1')?.value || '06:00-14:00',
                shift2: document.getElementById('shift2')?.value || '14:00-22:00',
                shift3: document.getElementById('shift3')?.value || '22:00-06:00'
            };
        }
        // --- Helpers to auto-sync Global Setup Window from Shift 1 and 2 ---
        function minutesToHHMM(total) {
            total = ((total % 1440) + 1440) % 1440; // normalize 0..1439
            const hh = String(Math.floor(total / 60)).padStart(2, '0');
            const mm = String(total % 60).padStart(2, '0');
            return `${hh}:${mm}`;
        }

        function parseTimeRange(range) {
            if (!range || typeof range !== 'string' || !range.includes('-')) return null;
            const [s, e] = range.split('-');
            const [sh, sm] = (s || '').split(':').map(n => parseInt(n, 10));
            const [eh, em] = (e || '').split(':').map(n => parseInt(n, 10));
            if ([sh, sm, eh, em].some(v => isNaN(v))) return null;
            const start = sh * 60 + sm;
            let end = eh * 60 + em;
            // Handle overnight like 22:00-06:00 by mapping end past midnight
            if (end <= start) end += 1440;
            return { start, end };
        }

        function syncSetupWindowFromShifts() {
            try {
                console.log('Syncing setup window from shifts...');
                const s1 = document.getElementById('shift1');
                const s2 = document.getElementById('shift2');
                console.log('Shift 1 value:', s1?.value);
                console.log('Shift 2 value:', s2?.value);

                const r1 = parseTimeRange(s1?.value);
                const r2 = parseTimeRange(s2?.value);
                console.log('Parsed Shift 1 range:', r1);
                console.log('Parsed Shift 2 range:', r2);

                if (!r1 && !r2) return; // nothing to do

                let startMin = null;
                let endMin = null;
                
                // Collect all ranges first
                const ranges = [];
                if (r1) ranges.push(r1);
                if (r2) ranges.push(r2);
                
                if (ranges.length > 0) {
                    startMin = Math.min(...ranges.map(r => r.start));
                    endMin = Math.max(...ranges.map(r => r.end));
                    console.log('Computed window (minutes):', { startMin, endMin });
                }

                // Clamp to 24h window for UI display
                const displayStart = minutesToHHMM(startMin);
                const displayEnd = minutesToHHMM(endMin);
                const ui = document.getElementById('setupAvailabilityWindow');
                if (ui) {
                    ui.value = `${displayStart}-${displayEnd}`;
                    console.log('Updated setupAvailabilityWindow to:', ui.value);
                }
            } catch (e) {
                console.warn('Failed to sync setup window from shifts:', e);
            }
        }

        function calculatePieceLevelScheduling(operations, order, machineSchedule, operatorSchedule) {
            const results = [];
            const batchQty = order.quantity;
            let previousOpPieceCompletionTimes = []; // Track when each piece completes from previous operation
            
            // Get order-specific settings
            const orderSettings = getOrderSettings(order);
            
            operations.forEach((operation, opIndex) => {
                // Select machine and operator for this operation
                const plannedStartTime = new Date(Math.max(
                    machineSchedule[operation.EligibleMachines[0]] || 0,
                    operatorSchedule['A'] || 0,
                    Date.now()
                ));
                const selectedMachine = selectOptimalMachine(operation, machineSchedule, orderSettings, plannedStartTime);
                const selectedOperator = selectOptimalOperator(operatorSchedule, machineSchedule[selectedMachine], orderSettings);
                
                // Setup Rule: Setup starts when first piece from previous operation is completed
                let setupStartTime;
                if (opIndex === 0) {
                    // First operation - setup starts based on machine/operator availability
                    // CRITICAL: Respect order-level startDateTime constraint
                    const globalStartTime = getGlobalStartTime();
                    const baseTime = globalStartTime ? globalStartTime.getTime() : Date.now();
                    const orderStartTime = orderSettings?.startDateTime ? orderSettings.startDateTime.getTime() : 0;
                    
                    setupStartTime = new Date(Math.max(
                        machineSchedule[selectedMachine]?.getTime() || 0,
                        operatorSchedule[selectedOperator]?.getTime() || 0,
                        baseTime,
                        orderStartTime // Enforce order-level start constraint
                    ));
                    
                    if (orderStartTime > 0) {
                        console.log(`Order-level start constraint: ${new Date(orderStartTime).toISOString()}`);
                        console.log(`Final setup start time: ${setupStartTime.toISOString()}`);
                    }
                } else {
                    // Subsequent operations - setup starts when first piece from previous op is done
                    // Still need to respect order-level constraint for consistency
                    const orderStartTime = orderSettings?.startDateTime ? orderSettings.startDateTime.getTime() : 0;
                    
                    setupStartTime = new Date(Math.max(
                        previousOpPieceCompletionTimes[0]?.getTime() || 0,
                        machineSchedule[selectedMachine]?.getTime() || 0,
                        operatorSchedule[selectedOperator]?.getTime() || 0,
                        orderStartTime // Ensure subsequent ops also respect order constraint
                    ));
                }
                
                // NEW: Enforce machine breakdown at setup start planning point
                setupStartTime = adjustTimeForBreakdowns(setupStartTime, selectedMachine);
                
                // CRITICAL: Push setupStartTime into Global Setup Window BEFORE any calculations
                const setupWindowStr = orderSettings ? orderSettings.setupWindow : getSetupWindow();
                const setupWindow = parseSetupWindow(setupWindowStr);
                setupStartTime = enforceSetupStartInWindow(setupStartTime, setupWindow);
                
                // Apply setup window constraints - FIXED: Handle undefined setupWindow
                let setupStart, setupEnd;
                try {
                    // Check if Operator=1 flag requires operator shift alignment
                    if (operation.Operator == 1) {
                        console.log(`Operation ${operation.OperationSeq} has Operator=1 - enforcing operator shift alignment`);
                        const alignedSetup = alignSetupToOperatorShift(setupStartTime, operation.SetupTime_Min, orderSettings);
                        setupStart = alignedSetup.setupStart;
                        setupEnd = alignedSetup.setupEnd;
                    } else {
                        console.log(`Operation ${operation.OperationSeq} has no operator restriction - using standard setup window`);
                        const setupSchedule = calculateShiftAwareSchedule(
                            setupStartTime,
                            setupStartTime,
                            operation.SetupTime_Min,
                            0, // No run time for setup phase
                            orderSettings
                        );
                        setupStart = setupSchedule.setupStart;
                        setupEnd = setupSchedule.setupEnd;
                    }
                    
                    // MACHINE BREAKDOWN ENFORCEMENT for SETUP
                    console.log(`🔧 SETUP BREAKDOWN CHECK: Checking breakdowns for machine ${selectedMachine}`);
                    const setupBreakdownResult = adjustOperationForBreakdowns(setupStart, setupEnd, selectedMachine, 'SETUP');
                    setupStart = setupBreakdownResult.adjustedStart;
                    setupEnd = setupBreakdownResult.adjustedEnd;
                    
                    if (setupBreakdownResult.breakdownPauses.length > 0) {
                        console.log(`🔧 SETUP BREAKDOWN ADJUSTMENTS: ${setupBreakdownResult.breakdownPauses.length} pauses applied`);
                        setupBreakdownResult.breakdownPauses.forEach(pause => {
                            console.log(`   - ${pause.reason}: ${pause.pauseStart.toISOString()} → ${pause.pauseEnd.toISOString()} (${pause.delayMinutes.toFixed(1)} min delay)`);
                        });
                    }
                } catch (error) {
                    console.error('Error in setup scheduling:', error);
                    // Fallback: simple setup calculation without shift constraints
                    setupStart = new Date(setupStartTime);
                    setupEnd = new Date(setupStart.getTime() + operation.SetupTime_Min * 60000);
                }
                
                // Machine becomes available after setup — but enforce breakdown window at availability point
                let machineAvailableTime = adjustTimeForBreakdowns(new Date(setupEnd), selectedMachine);
                
                // Piece Flow Rule: Process each piece individually
                const pieceRunTimes = [];
                const pieceCompletionTimes = [];
                
                for (let pieceIndex = 0; pieceIndex < batchQty; pieceIndex++) {
                    // When is this piece ready from previous operation?
                    let pieceReadyTime;
                    if (opIndex === 0) {
                        // First operation - all pieces ready at setup end
                        pieceReadyTime = new Date(setupEnd);
                    } else {
                        // Piece ready when it completed previous operation
                        pieceReadyTime = previousOpPieceCompletionTimes[pieceIndex] || new Date(setupEnd);
                    }
                    
                    // RunStartTime = max(PieceReadyTime, MachineAvailableTime), then push out of any breakdown window
                    const plannedRunStart = new Date(Math.max(
                        pieceReadyTime.getTime(),
                        machineAvailableTime.getTime()
                    ));
                    const runStartTime = adjustTimeForBreakdowns(plannedRunStart, selectedMachine);
                    
                    // MACHINE BREAKDOWN ENFORCEMENT for RUN (per piece)
                    console.log(`🔧 RUN BREAKDOWN CHECK: Checking breakdowns for machine ${selectedMachine} piece ${pieceIndex + 1}`);
                    const initialRunEndTime = new Date(runStartTime.getTime() + operation.CycleTime_Min * 60000);

                    // NEW: MANDATORY HOLIDAY ENFORCEMENT for RUN (per piece)
                    const runHolidayResult = adjustOperationForHolidays(runStartTime, initialRunEndTime, 'RUN');
                    const holidayAdjustedRunStart = runHolidayResult.adjustedStart;
                    const holidayAdjustedRunEnd = runHolidayResult.adjustedEnd;

                    // Then apply MACHINE BREAKDOWN ENFORCEMENT to holiday-adjusted window
                    const runBreakdownResult = adjustOperationForBreakdowns(holidayAdjustedRunStart, holidayAdjustedRunEnd, selectedMachine, 'RUN');
                    
                    // Use breakdown-adjusted times
                    let adjustedRunStart = runBreakdownResult.adjustedStart;
                    let runEndTime = runBreakdownResult.adjustedEnd;

                    // ENFORCE Production Window (Machine-Dependent)
                    const prodShifts = getProductionShiftsFromUI();
                    const durationMinutes = Math.max(0, Math.round((runEndTime.getTime() - adjustedRunStart.getTime()) / 60000));
                    const enforced = calculateProductionWithShiftBoundaries(adjustedRunStart, durationMinutes, prodShifts);
                    adjustedRunStart = enforced.runStart;
                    runEndTime = enforced.runEnd;
                    
                    if (runBreakdownResult.breakdownPauses.length > 0) {
                        console.log(`🔧 RUN BREAKDOWN ADJUSTMENTS for piece ${pieceIndex + 1}: ${runBreakdownResult.breakdownPauses.length} pauses applied`);
                        runBreakdownResult.breakdownPauses.forEach(pause => {
                            console.log(`   - ${pause.reason}: ${pause.pauseStart.toISOString()} → ${pause.pauseEnd.toISOString()} (${pause.delayMinutes.toFixed(1)} min delay)`);
                        });
                    }
                    
                    pieceRunTimes.push({
                        piece: pieceIndex + 1,
                        runStart: adjustedRunStart,
                        runEnd: runEndTime
                    });
                    
                    pieceCompletionTimes.push(runEndTime);
                    
                    // Update machine availability for next piece
                    machineAvailableTime = new Date(runEndTime);
                }
                
                // Operation completion times
                const firstPieceDone = pieceCompletionTimes[0];
                const lastPieceDone = pieceCompletionTimes[batchQty - 1];
                const operationRunStart = pieceRunTimes[0].runStart;
                const operationRunEnd = lastPieceDone;
                
                // Calculate timing description
                const totalElapsed = (operationRunEnd.getTime() - setupStart.getTime()) / (1000 * 60);
                const actualWork = operation.SetupTime_Min + (operation.CycleTime_Min * batchQty);
                const pausedTime = totalElapsed - actualWork;
                
                results.push({
                    OperationSeq: operation.OperationSeq,
                    OperationName: operation.OperationName,
                    Machine: selectedMachine,
                    Person: selectedOperator,
                    SetupStart: setupStart,
                    SetupEnd: setupEnd,
                    RunStart: operationRunStart,
                    RunEnd: operationRunEnd,
                    actualRunEnd: operationRunEnd, // For updating schedules
                    FirstPieceDone: firstPieceDone,
                    LastPieceDone: lastPieceDone,
                    PieceDetails: pieceRunTimes,
                    Timing: `${formatDuration(totalElapsed)} (${formatDuration(actualWork)} Work)`
                });
                
                // Update machine and operator schedules to prevent overlaps
                machineSchedule[selectedMachine] = new Date(operationRunEnd);
                operatorSchedule[selectedOperator] = new Date(operationRunEnd);
                
                // Update previous operation piece completion times for next iteration
                previousOpPieceCompletionTimes = pieceCompletionTimes;
            });
            
            return results;
        }

        function getOrderSettings(order) {
            // Get global settings
            const globalSettings = {
                breakdownMachines: getBreakdownMachines(),
                breakdownDateTime: getBreakdownDateTime(),
                startDateTime: getStartDateTime(),
                holidays: getHolidays(),
                setupWindow: getSetupWindow(),
                shifts: getShifts()
            };

            // Override with order-specific settings if provided
            const orderSettings = { ...globalSettings };

            if (order.breakdownMachine) {
                orderSettings.breakdownMachines = [order.breakdownMachine];
            }
            if (order.breakdownDateTime) {
                orderSettings.breakdownDateTime = order.breakdownDateTime;
            }
            if (order.startDateTime) {
                const od = new Date(order.startDateTime);
                if (!isNaN(od.getTime())) {
                    orderSettings.startDateTime = od;
                } else {
                    console.warn('Ignoring invalid Order Start Date-Time:', order.startDateTime);
                }
            }
            if (order.holidayRange) {
                orderSettings.holidays = [order.holidayRange];
            }
            if (order.setupWindow) {
                orderSettings.setupWindow = order.setupWindow;
            }

            return orderSettings;
        }

        function selectOptimalMachine(operation, machineSchedule, orderSettings = null, plannedStartTime = null) {
            const eligibleMachines = operation.EligibleMachines;
            const breakdowns = getBreakdowns();
            
            // Smart filtering: avoid machines with active breakdowns during planned operation window
            const availableMachines = eligibleMachines.filter(machine => {
                // Check if machine has breakdown during planned operation time
                if (plannedStartTime && breakdowns.length > 0) {
                    const machineAvailableTime = machineSchedule[machine] || plannedStartTime;
                    const operationStart = new Date(Math.max(plannedStartTime.getTime(), machineAvailableTime.getTime()));
                    
                    // Estimate operation duration (setup + run time)
                    const estimatedDuration = (operation.SetupTime_Min || 0) + (operation.CycleTime_Min || 0);
                    const operationEnd = new Date(operationStart.getTime() + estimatedDuration * 60000);
                    
                    // Check if any breakdown overlaps with this operation window
                    const hasBreakdownConflict = breakdowns.some(breakdown => {
                        if (!breakdown.machines.includes(machine)) return false;
                        
                        // Check for overlap: breakdown overlaps if it starts before operation ends and ends after operation starts
                        return breakdown.start < operationEnd && breakdown.end > operationStart;
                    });
                    
                    if (hasBreakdownConflict) {
                        console.log(`🚫 Avoiding machine ${machine} due to breakdown conflict during planned operation`);
                        return false;
                    }
                }
                
                return true;
            });
            
            if (availableMachines.length === 0) {
                console.warn(`⚠️ All eligible machines have breakdown conflicts, using first eligible: ${eligibleMachines[0]}`);
                return eligibleMachines[0]; // Fallback to first eligible if all are broken
            }
            
            // Select machine with earliest availability from non-conflicted machines
            const selectedMachine = availableMachines.reduce((best, current) => {
                const bestTime = machineSchedule[best] || new Date();
                const currentTime = machineSchedule[current] || new Date();
                return currentTime < bestTime ? current : best;
            });
            
            console.log(`✅ Selected machine ${selectedMachine} from available: [${availableMachines.join(', ')}]`);
            return selectedMachine;
        }

        function selectOptimalOperator(operatorSchedule, machineStartTime, orderSettings = null) {
            // Use order-specific shifts or fall back to global
            const shifts = orderSettings ? orderSettings.shifts : getShifts();
            
            // Parse shift times from settings
            const shift1 = parseShiftTime(shifts.shift1); // 06:00-14:00 -> A, B
            const shift2 = parseShiftTime(shifts.shift2); // 14:00-22:00 -> C, D
            const shift3 = parseShiftTime(shifts.shift3); // 22:00-06:00 -> Optional
            
            const startTime = new Date(Math.max(machineStartTime.getTime(), Date.now()));
            
            // Determine which shift the setup will occur in
            const hour = startTime.getHours();
            const minute = startTime.getMinutes();
            const timeInMinutes = hour * 60 + minute;
            
            let availableOperators = [];
            
            // Check which shift we're in
            if (timeInMinutes >= shift1.start && timeInMinutes < shift1.end) {
                availableOperators = ['A', 'B'];
            } else if (timeInMinutes >= shift2.start && timeInMinutes < shift2.end) {
                availableOperators = ['C', 'D'];
            } else if (shift3.enabled && (timeInMinutes >= shift3.start || timeInMinutes < shift3.end)) {
                availableOperators = ['A', 'B']; // Fallback to A, B for night shift
            } else {
                availableOperators = ['A', 'B']; // Default fallback
            }
            
            // Select operator with earliest availability
            return availableOperators.reduce((best, current) => {
                const bestTime = operatorSchedule[best] || new Date();
                const currentTime = operatorSchedule[current] || new Date();
                return currentTime < bestTime ? current : best;
            });
        }

        function parseShiftTime(shiftString) {
            if (!shiftString || typeof shiftString !== 'string') {
                console.warn('Invalid shift string:', shiftString);
                return { start: 0, end: 24 * 60 }; // Default to 24x7
            }
            const [start, end] = shiftString.split('-');
            if (!start || !end) {
                console.warn('Malformed shift string:', shiftString);
                return { start: 0, end: 24 * 60 };
            }
            const startMinutes = parseInt(start.split(':')[0]) * 60 + parseInt(start.split(':')[1]);
            const endMinutes = parseInt(end.split(':')[0]) * 60 + parseInt(end.split(':')[1]);
            return {
                start: startMinutes,
                end: endMinutes
            };
        }

        function parseSetupWindow(windowString) {
            if (!windowString || typeof windowString !== 'string') {
                console.error('Invalid setup window string, using getSetupWindow() fallback:', windowString);
                // Use the improved getSetupWindow() function for consistent fallback behavior
                windowString = getSetupWindow();
                console.log('Using getSetupWindow() fallback value:', windowString);
            }
            
            const [start, end] = windowString.split('-');
            if (!start || !end) {
                console.error('Invalid setup window format:', windowString);
                return { start: 6, end: 22 }; // Last resort fallback
            }
            
            const startParts = start.split(':');
            const endParts = end.split(':');
            
            if (!startParts[0] || !endParts[0]) {
                console.error('Invalid time format in setup window:', windowString);
                return { start: 6, end: 22 }; // Last resort fallback
            }
            
            const startHour = parseInt(startParts[0]);
            const endHour = parseInt(endParts[0]);
            
            if (isNaN(startHour) || isNaN(endHour)) {
                console.error('Invalid hour values in setup window:', windowString);
                return { start: 6, end: 22 }; // Last resort fallback
            }
            
            console.log('✅ ENFORCING Setup Window:', { start: startHour, end: endHour, original: windowString });
            
            return {
                start: startHour,
                end: endHour
            };
        }

        function displayResults() {
            const resultsCard = document.getElementById('resultsCard');
            const alertsContainer = document.getElementById('scheduleAlerts');
            const tbody = document.getElementById('resultsTableBody');

            // Display alerts if any
            if (scheduleResults.alerts && scheduleResults.alerts.length > 0) {
                alertsContainer.innerHTML = scheduleResults.alerts.map(alert => 
                    `<div class="alert alert-error">${alert}</div>`
                ).join('');
            } else {
                alertsContainer.innerHTML = '';
            }

            // Display results table
            if (scheduleResults.rows && scheduleResults.rows.length > 0) {
                tbody.innerHTML = scheduleResults.rows.map(row => `
                    <tr>
                        <td>${row.PartNumber}</td>
                        <td>${row.Order_Quantity}</td>
                        <td>${row.Priority}</td>
                        <td>${row.Batch_ID}</td>
                        <td>${row.Batch_Qty}</td>
                        <td>${row.OperationSeq}</td>
                        <td>${row.OperationName}</td>
                        <td>${row.Machine}</td>
                        <td>${row.Person}</td>
                        <td class="nowrap">${row.SetupStart}</td>
                        <td class="nowrap">${row.SetupEnd}</td>
                        <td class="nowrap">${row.RunStart}</td>
                        <td class="nowrap">${row.RunEnd}</td>
                        <td class="nowrap">${row.Timing}</td>
                        <td class="nowrap">${row.DueDate}</td>
                    </tr>
                `).join('');
            } else {
                tbody.innerHTML = '<tr><td colspan="15" style="text-align: center; color: #888;">No results to display</td></tr>';
            }

            resultsCard.style.display = 'block';
            resultsCard.scrollIntoView({ behavior: 'smooth' });
        }

        function exportToExcel() {
            if (!scheduleResults.rows || scheduleResults.rows.length === 0) {
                alert('No data to export');
                return;
            }

            try {
                const ws = XLSX.utils.json_to_sheet(scheduleResults.rows);
                const wb = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(wb, ws, "Schedule Results");

                // Generate filename with timestamp
                const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
                const filename = `production_schedule_${timestamp}.xlsx`;

                XLSX.writeFile(wb, filename);
                showAlert('Excel file exported successfully!', 'success');
            } catch (error) {
                console.error('Export error:', error);
                showAlert('Error exporting to Excel: ' + error.message, 'error');
            }
        }

        function showAlert(message, type) {
            const alertDiv = document.createElement('div');
            alertDiv.className = `alert alert-${type}`;
            alertDiv.textContent = message;
            
            document.querySelector('.container').insertBefore(alertDiv, document.querySelector('.card'));
            
            setTimeout(() => {
                alertDiv.remove();
            }, 5000);
        }

        // Google Sheets Integration
        const GOOGLE_SHEETS_API_URL = 'https://script.google.com/macros/s/AKfycbwm_sPgJPGB7MViA1jow68rb-pAZGJKqskXIQdFBnDY_0QfpI9ObiUCI8fFZmrM-qbPGQ/exec';
        let lastSyncTimestamp = null;
        let isRefreshing = false;

        // Auto-sync interval (optional - set to 0 to disable)
        const AUTO_SYNC_INTERVAL_MINUTES = 5; // Set to 0 to disable auto-sync

        // Shared success handler
        function applyRoutingData(data) {
            if (!(data && data.meta && data.items)) {
                throw new Error('Invalid response format from Google Sheets API');
            }
            updateLocalRoutingData(data.items);
            persistRoutingData();
            // Also push to local writer service to update data.js on disk
            pushToLocalWriter(data.items);
            const syncStatus = document.getElementById('syncStatus');
            const lastSyncEl = document.getElementById('lastSync');
            lastSyncTimestamp = new Date();
            persistLastSync(lastSyncTimestamp);
            syncStatus.textContent = '✅ Google Sheets (saved)';
            lastSyncEl.textContent = `Last sync: ${lastSyncTimestamp.toLocaleString()}`;
            document.getElementById('partNumber').value = '';
            document.getElementById('operationSeqDisplay').value = '';
            document.getElementById('operationSeqDisplay').placeholder = 'Select a part number first';
            document.getElementById('operationSeqBtn').disabled = true;
            showAlert(`Successfully synced ${data.meta.rowCount} routing records from Google Sheets`, 'success');
            console.log('Routing data synced:', {
                totalRows: data.meta.rowCount,
                lastSync: data.meta.lastSync,
                sheetName: data.meta.sheetName
            });
        }

        // Send updated dataset to local writer (Node/Express) to overwrite data.js on disk
        function pushToLocalWriter(items) {
            const url = 'http://localhost:3000/update-data';
            fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ items }),
                mode: 'cors'
            })
            .then(async (res) => {
                if (!res.ok) throw new Error(await res.text());
                return res.json();
            })
            .then((resp) => {
                console.log('Local writer response:', resp);
                showAlert(`Local database updated (data.js) with ${items.length} rows.`, 'success');
            })
            .catch((err) => {
                console.warn('Local writer not available or failed:', err);
                // Non-blocking: continue without failing UI
                showAlert('Could not update local data.js automatically. Start the local writer or use Download data.js.', 'warning');
            });
        }

        // JSONP helper to bypass CORS when allowed by server
        function jsonpRequest(url, timeoutMs = 30000) {
            return new Promise((resolve, reject) => {
                const cbName = `__jsonp_cb_${Date.now()}_${Math.random().toString(36).slice(2)}`;
                const sep = url.includes('?') ? '&' : '?';
                const src = `${url}${sep}callback=${cbName}`;
                const script = document.createElement('script');
                let settled = false;

                const cleanup = () => {
                    if (script.parentNode) script.parentNode.removeChild(script);
                    try { delete window[cbName]; } catch (_) { window[cbName] = undefined; }
                };

                const timer = setTimeout(() => {
                    if (settled) return;
                    settled = true;
                    cleanup();
                    reject(new Error('JSONP timeout'));
                }, timeoutMs);

                window[cbName] = (data) => {
                    if (settled) return;
                    settled = true;
                    clearTimeout(timer);
                    cleanup();
                    resolve(data);
                };

                script.onerror = () => {
                    if (settled) return;
                    settled = true;
                    clearTimeout(timer);
                    cleanup();
                    reject(new Error('JSONP network error'));
                };

                script.src = src;
                document.head.appendChild(script);
            });
        }

        function refreshRoutingData() {
            if (isRefreshing) return;
            
            isRefreshing = true;
            const refreshBtn = document.getElementById('refreshDataBtn');
            const refreshIcon = document.getElementById('refreshIcon');
            const syncStatus = document.getElementById('syncStatus');
            const lastSyncEl = document.getElementById('lastSync');
            
            // Update UI to show loading state
            refreshBtn.disabled = true;
            refreshIcon.classList.add('spinning');
            syncStatus.textContent = '🔄 Syncing...';
            
            // Enhanced fetch with better error handling and timeout
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout
            
            fetch(GOOGLE_SHEETS_API_URL, {
                method: 'GET',
                cache: 'no-cache',
                signal: controller.signal
            })
                .then(response => {
                    clearTimeout(timeoutId);
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.error) {
                        throw new Error(data.error + (data.details ? ': ' + data.details : ''));
                    }
                    applyRoutingData(data);
                })
                .catch(error => {
                    clearTimeout(timeoutId);
                    console.error('Sync failed:', error);
                    
                    let errorMessage = 'Unknown error';
                    if (error.name === 'AbortError') {
                        errorMessage = 'Request timeout - check your internet connection';
                    } else if (error.message.includes('Failed to fetch')) {
                        errorMessage = 'Network error - verify Google Apps Script URL and deployment settings';
                    } else if (error.message.includes('CORS')) {
                        errorMessage = 'CORS error - redeploy Google Apps Script with proper permissions';
                    } else {
                        errorMessage = error.message;
                    }
                    // Try JSONP fallback on CORS or generic fetch failure
                    if (errorMessage.includes('CORS') || errorMessage.includes('Network error')) {
                        return jsonpRequest(GOOGLE_SHEETS_API_URL)
                            .then(data => {
                                if (data && data.error) throw new Error(data.error);
                                applyRoutingData(data);
                            })
                            .catch(innerErr => {
                                syncStatus.textContent = '❌ Sync Failed';
                                showAlert(`Sync failed: ${errorMessage}`, 'error');
                                console.log('Troubleshooting tips:', {
                                    'Check URL': GOOGLE_SHEETS_API_URL,
                                    'Verify deployment': 'Ensure Google Apps Script is deployed as Web App',
                                    'Check permissions': 'Web App should have "Anyone with the link" access',
                                    'Test directly': 'Try opening the API URL in a browser tab'
                                });
                            });
                    } else {
                        syncStatus.textContent = '❌ Sync Failed';
                        showAlert(`Sync failed: ${errorMessage}`, 'error');
                        console.log('Troubleshooting tips:', {
                            'Check URL': GOOGLE_SHEETS_API_URL,
                            'Verify deployment': 'Ensure Google Apps Script is deployed as Web App',
                            'Check permissions': 'Web App should have "Anyone with the link" access',
                            'Test directly': 'Try opening the API URL in a browser tab'
                        });
                    }
                })
                .finally(() => {
                    // Reset UI state
                    isRefreshing = false;
                    refreshBtn.disabled = false;
                    refreshIcon.classList.remove('spinning');
                });
        }

        function updateLocalRoutingData(newItems) {
            // Clear existing data
            window.OP_MASTER = [];
            
            // Convert Google Sheets data to local format
            newItems.forEach(item => {
                window.OP_MASTER.push({
                    PartNumber: String(item.PartNumber).trim(),
                    OperationSeq: parseInt(item.OperationSeq) || 0,
                    OperationName: item.OperationName || '',
                    SetupTime_Min: parseFloat(item.SetupTime_Min) || 0,
                    Operator: item.Operator || '',
                    CycleTime_Min: parseFloat(item.CycleTime_Min) || 0,
                    Minimum_BatchSize: parseInt(item.Minimum_BatchSize) || 1,
                    EligibleMachines: Array.isArray(item.EligibleMachines) ? item.EligibleMachines : 
                        (typeof item.EligibleMachines === 'string' ? 
                            item.EligibleMachines.split(',').map(m => m.trim()).filter(m => m) : 
                            ['VMC 1'])
                });
            });
            
            console.log(`Updated local routing data with ${window.OP_MASTER.length} records`);
        }

        // Persist to localStorage so data survives page reloads
        function persistRoutingData() {
            try {
                localStorage.setItem('op_master', JSON.stringify(window.OP_MASTER));
                console.log('Persisted OP_MASTER to localStorage');
            } catch (e) {
                console.warn('Failed to persist OP_MASTER:', e);
            }
        }

        // Load from localStorage if present
        function loadPersistedRoutingData() {
            try {
                const raw = localStorage.getItem('op_master');
                if (raw) {
                    const items = JSON.parse(raw);
                    updateLocalRoutingData(items);
                    const syncStatus = document.getElementById('syncStatus');
                    syncStatus.textContent = '📦 Local Cache';
                    console.log('Loaded OP_MASTER from localStorage');
                }
            } catch (e) {
                console.warn('Failed to load persisted OP_MASTER:', e);
            }
        }

        // Persist and restore last sync timestamp
        function persistLastSync(date) {
            try {
                localStorage.setItem('op_master_last_sync', date.toISOString());
            } catch (e) {
                console.warn('Failed to persist last sync time:', e);
            }
        }

        function loadPersistedLastSync() {
            try {
                const raw = localStorage.getItem('op_master_last_sync');
                if (raw) {
                    const dt = new Date(raw);
                    if (!isNaN(dt.getTime())) {
                        lastSyncTimestamp = dt;
                        const lastSyncEl = document.getElementById('lastSync');
                        lastSyncEl.textContent = `Last sync: ${dt.toLocaleString()}`;
                    }
                }
            } catch (e) {
                console.warn('Failed to load last sync time:', e);
            }
        }

        // Download a fresh data.js file for the repo
        function downloadDataJs() {
            try {
                const content = 'window.OP_MASTER = ' + JSON.stringify(window.OP_MASTER, null, 2) + ';\n';
                const blob = new Blob([content], { type: 'application/javascript' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'data.js';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showAlert('Downloaded updated data.js. Replace the file in your project to make it permanent.', 'success');
            } catch (e) {
                showAlert('Failed to build data.js: ' + e.message, 'error');
            }
        }

        // Initialize auto-sync if enabled
        function initializeAutoSync() {
            if (AUTO_SYNC_INTERVAL_MINUTES > 0) {
                setInterval(() => {
                    if (!isRefreshing) {
                        console.log('Auto-syncing routing data...');
                        refreshRoutingData();
                    }
                }, AUTO_SYNC_INTERVAL_MINUTES * 60 * 1000);
                
                console.log(`Auto-sync enabled: every ${AUTO_SYNC_INTERVAL_MINUTES} minutes`);
            }
        }

        // Removed duplicate DOMContentLoaded listener - consolidated above
        
        function initializeSyncStatus() {
            // Show initial sync status
            const syncStatus = document.getElementById('syncStatus');
            if (window.OP_MASTER && window.OP_MASTER.length > 0) {
                syncStatus.textContent = '📊 Local Data';
            } else {
                syncStatus.textContent = '⚠️ No Data';
            }
        }
    </script>
</body>
</html>
